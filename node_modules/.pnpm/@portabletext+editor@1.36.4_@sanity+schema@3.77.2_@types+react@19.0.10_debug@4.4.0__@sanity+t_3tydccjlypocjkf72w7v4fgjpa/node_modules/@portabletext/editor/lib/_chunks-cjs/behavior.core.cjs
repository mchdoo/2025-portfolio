"use strict";
var selector_isAtTheStartOfBlock = require("./selector.is-at-the-start-of-block.cjs"), types = require("@sanity/types"), util_sliceBlocks = require("./util.slice-blocks.cjs");
function isCustomBehaviorEvent(event) {
  return event.type.startsWith("custom.");
}
function raise(event) {
  return {
    type: "raise",
    event
  };
}
function defineBehavior(behavior) {
  return behavior;
}
const addAnnotationOnCollapsedSelection = {
  on: "annotation.add",
  guard: ({
    snapshot
  }) => {
    if (!selector_isAtTheStartOfBlock.isSelectionCollapsed(snapshot))
      return !1;
    const caretWordSelection = selector_isAtTheStartOfBlock.getCaretWordSelection(snapshot);
    return !caretWordSelection || !selector_isAtTheStartOfBlock.isSelectionExpanded({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: caretWordSelection
      }
    }) ? !1 : {
      caretWordSelection
    };
  },
  actions: [({
    event
  }, {
    caretWordSelection
  }) => [raise({
    type: "select",
    selection: caretWordSelection
  }), raise({
    type: "annotation.add",
    annotation: event.annotation
  })]]
}, coreAnnotationBehaviors = {
  addAnnotationOnCollapsedSelection
}, IS_MAC = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.userAgent), modifiers = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, aliases = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: IS_MAC ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, keyCodes = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222,
  f1: 112,
  f2: 113,
  f3: 114,
  f4: 115,
  f5: 116,
  f6: 117,
  f7: 118,
  f8: 119,
  f9: 120,
  f10: 121,
  f11: 122,
  f12: 123,
  f13: 124,
  f14: 125,
  f15: 126,
  f16: 127,
  f17: 128,
  f18: 129,
  f19: 130,
  f20: 131
};
function isHotkey(hotkey, event) {
  return compareHotkey(parseHotkey(hotkey), event);
}
function parseHotkey(hotkey) {
  const parsedHotkey = {
    altKey: !1,
    ctrlKey: !1,
    metaKey: !1,
    shiftKey: !1
  }, hotkeySegments = hotkey.replace("++", "+add").split("+");
  for (const rawHotkeySegment of hotkeySegments) {
    const optional = rawHotkeySegment.endsWith("?") && rawHotkeySegment.length > 1, hotkeySegment = optional ? rawHotkeySegment.slice(0, -1) : rawHotkeySegment, keyName = toKeyName(hotkeySegment), modifier = modifiers[keyName], alias = aliases[hotkeySegment], code = keyCodes[keyName];
    if (hotkeySegment.length > 1 && modifier === void 0 && alias === void 0 && code === void 0)
      throw new TypeError(`Unknown modifier: "${hotkeySegment}"`);
    (hotkeySegments.length === 1 || modifier === void 0) && (parsedHotkey.key = keyName, parsedHotkey.keyCode = toKeyCode(hotkeySegment)), modifier !== void 0 && (parsedHotkey[modifier] = optional ? null : !0);
  }
  return parsedHotkey;
}
function compareHotkey(parsedHotkey, event) {
  return (parsedHotkey.altKey == null || parsedHotkey.altKey === event.altKey) && (parsedHotkey.ctrlKey == null || parsedHotkey.ctrlKey === event.ctrlKey) && (parsedHotkey.metaKey == null || parsedHotkey.metaKey === event.metaKey) && (parsedHotkey.shiftKey == null || parsedHotkey.shiftKey === event.shiftKey) ? parsedHotkey.keyCode !== void 0 && event.keyCode !== void 0 ? parsedHotkey.keyCode === 91 && event.keyCode === 93 ? !0 : parsedHotkey.keyCode === event.keyCode : parsedHotkey.keyCode === event.keyCode || parsedHotkey.key === event.key.toLowerCase() : !1;
}
function toKeyCode(name) {
  const keyName = toKeyName(name);
  return keyCodes[keyName] ?? keyName.toUpperCase().charCodeAt(0);
}
function toKeyName(name) {
  const keyName = name.toLowerCase();
  return aliases[keyName] ?? keyName;
}
const arrowDownOnLonelyBlockObject = {
  on: "key.down",
  guard: ({
    snapshot,
    event
  }) => {
    const isArrowDown = isHotkey("ArrowDown", event.keyboardEvent), focusBlockObject = selector_isAtTheStartOfBlock.getFocusBlockObject(snapshot), nextBlock = selector_isAtTheStartOfBlock.getNextBlock(snapshot);
    return isArrowDown && focusBlockObject && !nextBlock;
  },
  actions: [() => [raise({
    type: "insert.text block",
    placement: "after"
  })]]
}, arrowUpOnLonelyBlockObject = {
  on: "key.down",
  guard: ({
    snapshot,
    event
  }) => {
    const isArrowUp = isHotkey("ArrowUp", event.keyboardEvent), focusBlockObject = selector_isAtTheStartOfBlock.getFocusBlockObject(snapshot), previousBlock = selector_isAtTheStartOfBlock.getPreviousBlock(snapshot);
    return isArrowUp && focusBlockObject && !previousBlock;
  },
  actions: [() => [raise({
    type: "insert.text block",
    placement: "before"
  }), raise({
    type: "select.previous block"
  })]]
}, breakingBlockObject = {
  on: "insert.break",
  guard: ({
    snapshot
  }) => {
    const focusBlockObject = selector_isAtTheStartOfBlock.getFocusBlockObject(snapshot);
    return selector_isAtTheStartOfBlock.isSelectionCollapsed(snapshot) && focusBlockObject !== void 0;
  },
  actions: [() => [raise({
    type: "insert.text block",
    placement: "after"
  })]]
}, deletingEmptyTextBlockAfterBlockObject = {
  on: "delete.backward",
  guard: ({
    snapshot
  }) => {
    const focusTextBlock = selector_isAtTheStartOfBlock.getFocusTextBlock(snapshot), selectionCollapsed = selector_isAtTheStartOfBlock.isSelectionCollapsed(snapshot), previousBlock = selector_isAtTheStartOfBlock.getPreviousBlock(snapshot);
    return !focusTextBlock || !selectionCollapsed || !previousBlock ? !1 : util_sliceBlocks.isEmptyTextBlock(focusTextBlock.node) && !types.isPortableTextTextBlock(previousBlock.node) ? {
      focusTextBlock,
      previousBlock
    } : !1;
  },
  actions: [(_, {
    focusTextBlock,
    previousBlock
  }) => [raise({
    type: "delete.block",
    blockPath: focusTextBlock.path
  }), raise({
    type: "select",
    selection: {
      anchor: {
        path: previousBlock.path,
        offset: 0
      },
      focus: {
        path: previousBlock.path,
        offset: 0
      }
    }
  })]]
}, deletingEmptyTextBlockBeforeBlockObject = {
  on: "delete.forward",
  guard: ({
    snapshot
  }) => {
    const focusTextBlock = selector_isAtTheStartOfBlock.getFocusTextBlock(snapshot), selectionCollapsed = selector_isAtTheStartOfBlock.isSelectionCollapsed(snapshot), nextBlock = selector_isAtTheStartOfBlock.getNextBlock(snapshot);
    return !focusTextBlock || !selectionCollapsed || !nextBlock ? !1 : util_sliceBlocks.isEmptyTextBlock(focusTextBlock.node) && !types.isPortableTextTextBlock(nextBlock.node) ? {
      focusTextBlock,
      nextBlock
    } : !1;
  },
  actions: [(_, {
    focusTextBlock,
    nextBlock
  }) => [raise({
    type: "delete.block",
    blockPath: focusTextBlock.path
  }), raise({
    type: "select",
    selection: {
      anchor: {
        path: nextBlock.path,
        offset: 0
      },
      focus: {
        path: nextBlock.path,
        offset: 0
      }
    }
  })]]
}, coreBlockObjectBehaviors = {
  arrowDownOnLonelyBlockObject,
  arrowUpOnLonelyBlockObject,
  breakingBlockObject,
  deletingEmptyTextBlockAfterBlockObject,
  deletingEmptyTextBlockBeforeBlockObject
}, coreDecoratorBehaviors = {
  strongShortcut: {
    on: "key.down",
    guard: ({
      snapshot,
      event
    }) => isHotkey("mod+b", event.keyboardEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.value === "strong"),
    actions: [() => [raise({
      type: "decorator.toggle",
      decorator: "strong"
    })]]
  },
  emShortcut: {
    on: "key.down",
    guard: ({
      snapshot,
      event
    }) => isHotkey("mod+i", event.keyboardEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.value === "em"),
    actions: [() => [raise({
      type: "decorator.toggle",
      decorator: "em"
    })]]
  },
  underlineShortcut: {
    on: "key.down",
    guard: ({
      snapshot,
      event
    }) => isHotkey("mod+u", event.keyboardEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.value === "underline"),
    actions: [() => [raise({
      type: "decorator.toggle",
      decorator: "underline"
    })]]
  },
  codeShortcut: {
    on: "key.down",
    guard: ({
      snapshot,
      event
    }) => isHotkey("mod+'", event.keyboardEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.value === "code"),
    actions: [() => [raise({
      type: "decorator.toggle",
      decorator: "code"
    })]]
  }
}, breakingAtTheEndOfTextBlock = {
  on: "insert.break",
  guard: ({
    snapshot
  }) => {
    const focusTextBlock = selector_isAtTheStartOfBlock.getFocusTextBlock(snapshot), selectionCollapsed = selector_isAtTheStartOfBlock.isSelectionCollapsed(snapshot);
    if (!snapshot.context.selection || !focusTextBlock || !selectionCollapsed)
      return !1;
    const atTheEndOfBlock = selector_isAtTheStartOfBlock.isAtTheEndOfBlock(focusTextBlock)(snapshot), focusListItem = focusTextBlock.node.listItem, focusLevel = focusTextBlock.node.level;
    return atTheEndOfBlock ? {
      focusListItem,
      focusLevel
    } : !1;
  },
  actions: [({
    snapshot
  }, {
    focusListItem,
    focusLevel
  }) => [raise({
    type: "insert.block",
    block: {
      _type: snapshot.context.schema.block.name,
      _key: snapshot.context.keyGenerator(),
      children: [{
        _key: snapshot.context.keyGenerator(),
        _type: snapshot.context.schema.span.name,
        text: "",
        marks: []
      }],
      markDefs: [],
      listItem: focusListItem,
      level: focusLevel,
      style: snapshot.context.schema.styles[0]?.value
    },
    placement: "after"
  })]]
}, breakingAtTheStartOfTextBlock = {
  on: "insert.break",
  guard: ({
    snapshot
  }) => {
    const focusTextBlock = selector_isAtTheStartOfBlock.getFocusTextBlock(snapshot), selectionCollapsed = selector_isAtTheStartOfBlock.isSelectionCollapsed(snapshot);
    if (!snapshot.context.selection || !focusTextBlock || !selectionCollapsed)
      return !1;
    const focusSpan = selector_isAtTheStartOfBlock.getFocusSpan(snapshot), focusDecorators = focusSpan?.node.marks?.filter((mark) => snapshot.context.schema.decorators.some((decorator) => decorator.value === mark) ?? []), focusAnnotations = focusSpan?.node.marks?.filter((mark) => !snapshot.context.schema.decorators.some((decorator) => decorator.value === mark)) ?? [], focusListItem = focusTextBlock.node.listItem, focusLevel = focusTextBlock.node.level;
    return selector_isAtTheStartOfBlock.isAtTheStartOfBlock(focusTextBlock)(snapshot) ? {
      focusAnnotations,
      focusDecorators,
      focusListItem,
      focusLevel
    } : !1;
  },
  actions: [({
    snapshot
  }, {
    focusAnnotations,
    focusDecorators,
    focusListItem,
    focusLevel
  }) => [raise({
    type: "insert.block",
    block: {
      _key: snapshot.context.keyGenerator(),
      _type: snapshot.context.schema.block.name,
      children: [{
        _key: snapshot.context.keyGenerator(),
        _type: snapshot.context.schema.span.name,
        marks: focusAnnotations.length === 0 ? focusDecorators : [],
        text: ""
      }],
      listItem: focusListItem,
      level: focusLevel,
      style: snapshot.context.schema.styles[0]?.value
    },
    placement: "before"
  })]]
}, coreInsertBreakBehaviors = {
  breakingAtTheEndOfTextBlock,
  breakingAtTheStartOfTextBlock
}, MAX_LIST_LEVEL = 10, clearListOnBackspace = {
  on: "delete.backward",
  guard: ({
    snapshot
  }) => {
    const selectionCollapsed = selector_isAtTheStartOfBlock.isSelectionCollapsed(snapshot), focusTextBlock = selector_isAtTheStartOfBlock.getFocusTextBlock(snapshot), focusSpan = selector_isAtTheStartOfBlock.getFocusSpan(snapshot);
    return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && snapshot.context.selection?.focus.offset === 0 && focusTextBlock.node.level === 1 ? {
      focusTextBlock
    } : !1;
  },
  actions: [(_, {
    focusTextBlock
  }) => [raise({
    type: "block.unset",
    props: ["listItem", "level"],
    at: focusTextBlock.path
  })]]
}, unindentListOnBackspace = {
  on: "delete.backward",
  guard: ({
    snapshot
  }) => {
    const selectionCollapsed = selector_isAtTheStartOfBlock.isSelectionCollapsed(snapshot), focusTextBlock = selector_isAtTheStartOfBlock.getFocusTextBlock(snapshot), focusSpan = selector_isAtTheStartOfBlock.getFocusSpan(snapshot);
    return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && snapshot.context.selection?.focus.offset === 0 && focusTextBlock.node.level !== void 0 && focusTextBlock.node.level > 1 ? {
      focusTextBlock,
      level: focusTextBlock.node.level - 1
    } : !1;
  },
  actions: [(_, {
    focusTextBlock,
    level
  }) => [raise({
    type: "block.set",
    props: {
      level
    },
    at: focusTextBlock.path
  })]]
}, clearListOnEnter = {
  on: "insert.break",
  guard: ({
    snapshot
  }) => {
    const selectionCollapsed = selector_isAtTheStartOfBlock.isSelectionCollapsed(snapshot), focusListBlock = selector_isAtTheStartOfBlock.getFocusListBlock(snapshot);
    return !selectionCollapsed || !focusListBlock || !util_sliceBlocks.isEmptyTextBlock(focusListBlock.node) ? !1 : {
      focusListBlock
    };
  },
  actions: [(_, {
    focusListBlock
  }) => [raise({
    type: "block.unset",
    props: ["listItem", "level"],
    at: focusListBlock.path
  })]]
}, indentListOnTab = {
  on: "key.down",
  guard: ({
    snapshot,
    event
  }) => {
    if (!isHotkey("Tab", event.keyboardEvent))
      return !1;
    const selectedBlocks = selector_isAtTheStartOfBlock.getSelectedBlocks(snapshot), guards = selector_isAtTheStartOfBlock.createGuards(snapshot.context), selectedListBlocks = selectedBlocks.flatMap((block) => guards.isListBlock(block.node) ? [{
      node: block.node,
      path: block.path
    }] : []);
    return selectedListBlocks.length === selectedBlocks.length ? {
      selectedListBlocks
    } : !1;
  },
  actions: [(_, {
    selectedListBlocks
  }) => selectedListBlocks.map((selectedListBlock) => raise({
    type: "block.set",
    props: {
      level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level + 1))
    },
    at: selectedListBlock.path
  }))]
}, unindentListOnShiftTab = {
  on: "key.down",
  guard: ({
    snapshot,
    event
  }) => {
    if (!isHotkey("Shift+Tab", event.keyboardEvent))
      return !1;
    const selectedBlocks = selector_isAtTheStartOfBlock.getSelectedBlocks(snapshot), guards = selector_isAtTheStartOfBlock.createGuards(snapshot.context), selectedListBlocks = selectedBlocks.flatMap((block) => guards.isListBlock(block.node) ? [{
      node: block.node,
      path: block.path
    }] : []);
    return selectedListBlocks.length === selectedBlocks.length ? {
      selectedListBlocks
    } : !1;
  },
  actions: [(_, {
    selectedListBlocks
  }) => selectedListBlocks.map((selectedListBlock) => raise({
    type: "block.set",
    props: {
      level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level - 1))
    },
    at: selectedListBlock.path
  }))]
}, coreListBehaviors = {
  clearListOnBackspace,
  unindentListOnBackspace,
  clearListOnEnter,
  indentListOnTab,
  unindentListOnShiftTab
}, coreBehaviors = [coreAnnotationBehaviors.addAnnotationOnCollapsedSelection, coreDecoratorBehaviors.strongShortcut, coreDecoratorBehaviors.emShortcut, coreDecoratorBehaviors.underlineShortcut, coreDecoratorBehaviors.codeShortcut, coreBlockObjectBehaviors.arrowDownOnLonelyBlockObject, coreBlockObjectBehaviors.arrowUpOnLonelyBlockObject, coreBlockObjectBehaviors.breakingBlockObject, coreBlockObjectBehaviors.deletingEmptyTextBlockAfterBlockObject, coreBlockObjectBehaviors.deletingEmptyTextBlockBeforeBlockObject, coreListBehaviors.clearListOnBackspace, coreListBehaviors.unindentListOnBackspace, coreListBehaviors.clearListOnEnter, coreListBehaviors.indentListOnTab, coreListBehaviors.unindentListOnShiftTab, coreInsertBreakBehaviors.breakingAtTheEndOfTextBlock, coreInsertBreakBehaviors.breakingAtTheStartOfTextBlock];
exports.coreBehaviors = coreBehaviors;
exports.defineBehavior = defineBehavior;
exports.isCustomBehaviorEvent = isCustomBehaviorEvent;
exports.isHotkey = isHotkey;
exports.raise = raise;
//# sourceMappingURL=behavior.core.cjs.map
