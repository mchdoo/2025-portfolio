{"version":3,"file":"index.cjs","sources":["../src/internal-utils/selection.ts","../src/editor/components/DefaultObject.tsx","../src/editor/components/drop-indicator.tsx","../src/editor/components/use-draggable.ts","../src/editor/components/use-droppable.ts","../src/editor/components/Element.tsx","../src/editor/components/Leaf.tsx","../src/editor/plugins/createWithHotKeys.ts","../src/editor/withSyncRangeDecorations.ts","../src/editor/Editable.tsx","../src/editor-event-listener.tsx"],"sourcesContent":["import type {Path, PortableTextBlock} from '@sanity/types'\nimport {isEqual} from 'lodash'\nimport type {EditorSelection, EditorSelectionPoint} from '../types/editor'\n\nexport function normalizePoint(\n  point: EditorSelectionPoint,\n  value: PortableTextBlock[],\n): EditorSelectionPoint | null {\n  if (!point || !value) {\n    return null\n  }\n  const newPath: Path = []\n  let newOffset: number = point.offset || 0\n  const blockKey =\n    typeof point.path[0] === 'object' &&\n    '_key' in point.path[0] &&\n    point.path[0]._key\n  const childKey =\n    typeof point.path[2] === 'object' &&\n    '_key' in point.path[2] &&\n    point.path[2]._key\n  const block: PortableTextBlock | undefined = value.find(\n    (blk) => blk._key === blockKey,\n  )\n  if (block) {\n    newPath.push({_key: block._key})\n  } else {\n    return null\n  }\n  if (block && point.path[1] === 'children') {\n    if (\n      !block.children ||\n      (Array.isArray(block.children) && block.children.length === 0)\n    ) {\n      return null\n    }\n    const child =\n      Array.isArray(block.children) &&\n      block.children.find((cld) => cld._key === childKey)\n    if (child) {\n      newPath.push('children')\n      newPath.push({_key: child._key})\n      newOffset =\n        child.text && child.text.length >= point.offset\n          ? point.offset\n          : (child.text && child.text.length) || 0\n    } else {\n      return null\n    }\n  }\n  return {path: newPath, offset: newOffset}\n}\n\nexport function normalizeSelection(\n  selection: EditorSelection,\n  value: PortableTextBlock[] | undefined,\n): EditorSelection | null {\n  if (!selection || !value || value.length === 0) {\n    return null\n  }\n  let newAnchor: EditorSelectionPoint | null = null\n  let newFocus: EditorSelectionPoint | null = null\n  const {anchor, focus} = selection\n  if (\n    anchor &&\n    value.find((blk) => isEqual({_key: blk._key}, anchor.path[0]))\n  ) {\n    newAnchor = normalizePoint(anchor, value)\n  }\n  if (focus && value.find((blk) => isEqual({_key: blk._key}, focus.path[0]))) {\n    newFocus = normalizePoint(focus, value)\n  }\n  if (newAnchor && newFocus) {\n    return {anchor: newAnchor, focus: newFocus, backward: selection.backward}\n  }\n  return null\n}\n","import type {PortableTextBlock, PortableTextChild} from '@sanity/types'\n\nexport function DefaultBlockObject(props: {\n  value: PortableTextBlock | PortableTextChild\n}) {\n  return (\n    <div style={{userSelect: 'none'}}>\n      [{props.value._type}: {props.value._key}]\n    </div>\n  )\n}\n\nexport function DefaultInlineObject(props: {\n  value: PortableTextBlock | PortableTextChild\n}) {\n  return (\n    <span style={{userSelect: 'none'}}>\n      [{props.value._type}: {props.value._key}]\n    </span>\n  )\n}\n","export function DropIndicator() {\n  return (\n    <div\n      className=\"pt-drop-indicator\"\n      style={{\n        position: 'absolute',\n        width: '100%',\n        height: 1,\n        borderBottom: '1px solid currentColor',\n        zIndex: 5,\n      }}\n    />\n  )\n}\n","import {\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n  type DragEvent,\n  type RefObject,\n} from 'react'\nimport {Path, Transforms, type Element as SlateElement} from 'slate'\nimport {ReactEditor, useSlateStatic} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {\n  IS_DRAGGING,\n  IS_DRAGGING_BLOCK_ELEMENT,\n  IS_DRAGGING_BLOCK_TARGET_POSITION,\n  IS_DRAGGING_ELEMENT_TARGET,\n} from '../../internal-utils/weakMaps'\n\nconst debug = debugWithName('useDraggable')\n\ntype Draggable = {\n  draggableProps: {\n    draggable: boolean\n    onDragStart?: (event: DragEvent) => void\n    onDrag?: (event: DragEvent) => void\n    onDragEnd?: (event: DragEvent) => void\n  }\n}\n\nexport function useDraggable(props: {\n  element: SlateElement\n  readOnly: boolean\n  blockRef: RefObject<HTMLDivElement | null>\n}): Draggable {\n  const editor = useSlateStatic()\n  const dragGhostRef = useRef<HTMLElement>(undefined)\n  const [blockElement, setBlockElement] = useState<HTMLElement | null>(null)\n\n  useEffect(\n    () =>\n      setBlockElement(\n        props.blockRef\n          ? props.blockRef.current\n          : ReactEditor.toDOMNode(editor, props.element),\n      ),\n    [editor, props.element, props.blockRef],\n  )\n\n  // Note: this is called for the dragging block\n  const handleDragEnd = useCallback(\n    (event: DragEvent) => {\n      const targetBlock = IS_DRAGGING_ELEMENT_TARGET.get(editor)\n      if (targetBlock) {\n        IS_DRAGGING.set(editor, false)\n        event.preventDefault()\n        event.stopPropagation()\n        IS_DRAGGING_ELEMENT_TARGET.delete(editor)\n        if (dragGhostRef.current) {\n          debug('Removing drag ghost')\n          document.body.removeChild(dragGhostRef.current)\n        }\n        const dragPosition = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor)\n        IS_DRAGGING_BLOCK_TARGET_POSITION.delete(editor)\n        let targetPath = ReactEditor.findPath(editor, targetBlock)\n        const myPath = ReactEditor.findPath(editor, props.element)\n        const isBefore = Path.isBefore(myPath, targetPath)\n        if (dragPosition === 'bottom' && !isBefore) {\n          // If it is already at the bottom, don't do anything.\n          if (targetPath[0] >= editor.children.length - 1) {\n            debug('target is already at the bottom, not moving')\n            return\n          }\n          const originalPath = targetPath\n          targetPath = Path.next(targetPath)\n          debug(\n            `Adjusting targetPath from ${JSON.stringify(originalPath)} to ${JSON.stringify(\n              targetPath,\n            )}`,\n          )\n        }\n        if (\n          dragPosition === 'top' &&\n          isBefore &&\n          targetPath[0] !== editor.children.length - 1\n        ) {\n          const originalPath = targetPath\n          targetPath = Path.previous(targetPath)\n          debug(\n            `Adjusting targetPath from ${JSON.stringify(originalPath)} to ${JSON.stringify(\n              targetPath,\n            )}`,\n          )\n        }\n        if (Path.equals(targetPath, myPath)) {\n          event.preventDefault()\n          debug('targetPath and myPath is the same, not moving')\n          return\n        }\n        debug(\n          `Moving element ${props.element._key} from path ${JSON.stringify(myPath)} to ${JSON.stringify(\n            targetPath,\n          )} (${dragPosition})`,\n        )\n        Transforms.moveNodes(editor, {at: myPath, to: targetPath})\n        editor.onChange()\n        return\n      }\n      debug('No target element, not doing anything')\n    },\n    [editor, props.element],\n  )\n\n  // Note: this is called for the dragging block\n  const handleDrag = useCallback(\n    (event: DragEvent) => {\n      IS_DRAGGING.set(editor, true)\n      IS_DRAGGING_BLOCK_ELEMENT.set(editor, props.element)\n      event.stopPropagation() // Stop propagation so that leafs don't get this and take focus/selection!\n\n      const target = event.target\n\n      if (target instanceof HTMLElement) {\n        target.style.opacity = '1'\n      }\n    },\n    [editor, props.element],\n  )\n\n  // Note: this is called for the dragging block\n  const handleDragStart = useCallback(\n    (event: DragEvent) => {\n      debug('Drag start')\n      IS_DRAGGING.set(editor, true)\n      if (event.dataTransfer) {\n        event.dataTransfer.setData('application/portable-text', 'something')\n        event.dataTransfer.effectAllowed = 'move'\n      }\n      // Clone blockElement so that it will not be visually clipped by scroll-containers etc.\n      // The application that uses the portable-text-editor may indicate the element used as\n      // drag ghost by adding a truthy data attribute 'data-pt-drag-ghost-element' to a HTML element.\n      if (blockElement && blockElement instanceof HTMLElement) {\n        let dragGhost = blockElement.cloneNode(true) as HTMLElement\n        const customGhost = dragGhost.querySelector(\n          '[data-pt-drag-ghost-element]',\n        )\n        if (customGhost) {\n          dragGhost = customGhost as HTMLElement\n        }\n\n        // Set the `data-dragged` attribute so the consumer can style the element while itâ€™s dragged\n        dragGhost.setAttribute('data-dragged', '')\n\n        if (document.body) {\n          dragGhostRef.current = dragGhost\n          dragGhost.style.position = 'absolute'\n          dragGhost.style.left = '-99999px'\n          dragGhost.style.boxSizing = 'border-box'\n          document.body.appendChild(dragGhost)\n          const rect = blockElement.getBoundingClientRect()\n          const x = event.clientX - rect.left\n          const y = event.clientY - rect.top\n          dragGhost.style.width = `${rect.width}px`\n          dragGhost.style.height = `${rect.height}px`\n          event.dataTransfer.setDragImage(dragGhost, x, y)\n        }\n      }\n      handleDrag(event)\n    },\n    [blockElement, editor, handleDrag],\n  )\n\n  if (props.readOnly) {\n    return {\n      draggableProps: {\n        draggable: false,\n        onDragStart: undefined,\n        onDrag: undefined,\n        onDragEnd: undefined,\n      },\n    }\n  }\n\n  return {\n    draggableProps: {\n      draggable: true,\n      onDragStart: handleDragStart,\n      onDrag: handleDrag,\n      onDragEnd: handleDragEnd,\n    },\n  }\n}\n","import type React from 'react'\nimport {useCallback, useEffect, useState, type DragEvent} from 'react'\nimport type {Element as SlateElement} from 'slate'\nimport {ReactEditor, useSlateStatic} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {\n  IS_DRAGGING_BLOCK_ELEMENT,\n  IS_DRAGGING_BLOCK_TARGET_POSITION,\n  IS_DRAGGING_ELEMENT_TARGET,\n} from '../../internal-utils/weakMaps'\n\nconst debug = debugWithName('useDroppable')\n\ntype Droppable = {\n  droppableProps: {\n    onDragOver?: (event: DragEvent) => void\n    onDragLeave?: () => void\n    onDrop?: (event: DragEvent) => void\n  }\n  isDraggingOverTop: boolean\n  isDraggingOverBottom: boolean\n}\n\nexport function useDroppable(props: {\n  element: SlateElement\n  blockRef: React.RefObject<HTMLDivElement | null>\n  readOnly: boolean\n}): Droppable {\n  const editor = useSlateStatic()\n  const [isDragOver, setIsDragOver] = useState(false)\n  const [blockElement, setBlockElement] = useState<HTMLElement | null>(null)\n\n  useEffect(\n    () =>\n      setBlockElement(\n        props.blockRef\n          ? props.blockRef.current\n          : ReactEditor.toDOMNode(editor, props.element),\n      ),\n    [editor, props.element, props.blockRef],\n  )\n\n  const handleDragOver = useCallback(\n    (event: DragEvent) => {\n      const isMyDragOver = IS_DRAGGING_BLOCK_ELEMENT.get(editor)\n      // debug('Drag over', blockElement)\n      if (!isMyDragOver || !blockElement) {\n        return\n      }\n      event.preventDefault()\n      event.dataTransfer.dropEffect = 'move'\n      IS_DRAGGING_ELEMENT_TARGET.set(editor, props.element)\n      const elementRect = blockElement.getBoundingClientRect()\n      const offset = elementRect.top\n      const height = elementRect.height\n      const Y = event.pageY\n      const loc = Math.abs(offset - Y)\n      let position: 'top' | 'bottom' = 'bottom'\n      if (props.element === editor.children[0]) {\n        position = 'top'\n      } else if (loc < height / 2) {\n        position = 'top'\n        IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position)\n      } else {\n        position = 'bottom'\n        IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position)\n      }\n      if (isMyDragOver === props.element) {\n        event.dataTransfer.dropEffect = 'none'\n        return\n      }\n      setIsDragOver(true)\n    },\n    [blockElement, editor, props.element],\n  )\n\n  const handleDragLeave = useCallback(() => {\n    setIsDragOver(false)\n  }, [])\n\n  const handleDrop = useCallback(\n    (event: DragEvent) => {\n      if (IS_DRAGGING_BLOCK_ELEMENT.get(editor)) {\n        debug('On drop (prevented)', props.element)\n        event.preventDefault()\n        event.stopPropagation()\n        setIsDragOver(false)\n      }\n    },\n    [editor, props.element],\n  )\n\n  const isDraggingOverFirstBlock =\n    isDragOver && editor.children[0] === IS_DRAGGING_ELEMENT_TARGET.get(editor)\n  const isDraggingOverLastBlock =\n    isDragOver &&\n    editor.children[editor.children.length - 1] ===\n      IS_DRAGGING_ELEMENT_TARGET.get(editor)\n  const dragPosition = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor)\n\n  const isDraggingOverTop =\n    isDraggingOverFirstBlock ||\n    (isDragOver &&\n      !isDraggingOverFirstBlock &&\n      !isDraggingOverLastBlock &&\n      dragPosition === 'top')\n  const isDraggingOverBottom =\n    isDraggingOverLastBlock ||\n    (isDragOver &&\n      !isDraggingOverFirstBlock &&\n      !isDraggingOverLastBlock &&\n      dragPosition === 'bottom')\n\n  if (props.readOnly) {\n    return {\n      droppableProps: {\n        onDragOver: undefined,\n        onDragLeave: undefined,\n        onDrop: undefined,\n      },\n      isDraggingOverTop: false,\n      isDraggingOverBottom: false,\n    }\n  }\n\n  return {\n    droppableProps: {\n      onDragOver: handleDragOver,\n      onDragLeave: handleDragLeave,\n      onDrop: handleDrop,\n    },\n    isDraggingOverTop,\n    isDraggingOverBottom,\n  }\n}\n","import type {\n  Path,\n  PortableTextChild,\n  PortableTextObject,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport {\n  useMemo,\n  useRef,\n  type FunctionComponent,\n  type JSX,\n  type ReactElement,\n} from 'react'\nimport {Editor, Range, Element as SlateElement} from 'slate'\nimport {\n  ReactEditor,\n  useSelected,\n  useSlateStatic,\n  type RenderElementProps,\n} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {fromSlateValue} from '../../internal-utils/values'\nimport {KEY_TO_VALUE_ELEMENT} from '../../internal-utils/weakMaps'\nimport type {\n  BlockRenderProps,\n  PortableTextMemberSchemaTypes,\n  RenderBlockFunction,\n  RenderChildFunction,\n  RenderListItemFunction,\n  RenderStyleFunction,\n} from '../../types/editor'\nimport {DefaultBlockObject, DefaultInlineObject} from './DefaultObject'\nimport {DropIndicator} from './drop-indicator'\nimport {useDraggable} from './use-draggable'\nimport {useDroppable} from './use-droppable'\n\nconst debug = debugWithName('components:Element')\nconst debugRenders = false\nconst EMPTY_ANNOTATIONS: PortableTextObject[] = []\n\n/**\n * @internal\n */\nexport interface ElementProps {\n  attributes: RenderElementProps['attributes']\n  children: ReactElement<any>\n  element: SlateElement\n  schemaTypes: PortableTextMemberSchemaTypes\n  readOnly: boolean\n  renderBlock?: RenderBlockFunction\n  renderChild?: RenderChildFunction\n  renderListItem?: RenderListItemFunction\n  renderStyle?: RenderStyleFunction\n  spellCheck?: boolean\n}\n\nconst inlineBlockStyle = {display: 'inline-block'}\n\n/**\n * Renders Portable Text block and inline object nodes in Slate\n * @internal\n */\nexport const Element: FunctionComponent<ElementProps> = ({\n  attributes,\n  children,\n  element,\n  schemaTypes,\n  readOnly,\n  renderBlock,\n  renderChild,\n  renderListItem,\n  renderStyle,\n  spellCheck,\n}) => {\n  const editor = useSlateStatic()\n  const selected = useSelected()\n  const blockRef = useRef<HTMLDivElement | null>(null)\n  const inlineBlockObjectRef = useRef(null)\n  const focused =\n    (selected && editor.selection && Range.isCollapsed(editor.selection)) ||\n    false\n  const droppable = useDroppable({element, blockRef, readOnly})\n  const draggable = useDraggable({element, blockRef, readOnly})\n\n  const value = useMemo(\n    () =>\n      fromSlateValue(\n        [element],\n        schemaTypes.block.name,\n        KEY_TO_VALUE_ELEMENT.get(editor),\n      )[0],\n    [editor, element, schemaTypes.block.name],\n  )\n\n  let renderedBlock = children\n\n  let className: string | undefined\n\n  const blockPath: Path = useMemo(() => [{_key: element._key}], [element])\n\n  if (typeof element._type !== 'string') {\n    throw new Error(`Expected element to have a _type property`)\n  }\n\n  if (typeof element._key !== 'string') {\n    throw new Error(`Expected element to have a _key property`)\n  }\n\n  // Test for inline objects first\n  if (editor.isInline(element)) {\n    const path = ReactEditor.findPath(editor, element)\n    const [block] = Editor.node(editor, path, {depth: 1})\n    const schemaType = schemaTypes.inlineObjects.find(\n      (_type) => _type.name === element._type,\n    )\n    if (!schemaType) {\n      throw new Error('Could not find type for inline block element')\n    }\n    if (SlateElement.isElement(block)) {\n      const elmPath: Path = [\n        {_key: block._key},\n        'children',\n        {_key: element._key},\n      ]\n      if (debugRenders) {\n        debug(`Render ${element._key} (inline object)`)\n      }\n      return (\n        <span {...attributes}>\n          {/* Note that children must follow immediately or cut and selections will not work properly in Chrome. */}\n          {children}\n          <span\n            draggable={!readOnly}\n            className=\"pt-inline-object\"\n            data-testid=\"pt-inline-object\"\n            ref={inlineBlockObjectRef}\n            key={element._key}\n            style={inlineBlockStyle}\n            contentEditable={false}\n          >\n            {renderChild &&\n              renderChild({\n                annotations: EMPTY_ANNOTATIONS, // These inline objects currently doesn't support annotations. This is a limitation of the current PT spec/model.\n                children: <DefaultInlineObject value={value} />,\n                editorElementRef: inlineBlockObjectRef,\n                focused,\n                path: elmPath,\n                schemaType,\n                selected,\n                type: schemaType,\n                value: value as PortableTextChild,\n              })}\n            {!renderChild && <DefaultInlineObject value={value} />}\n          </span>\n        </span>\n      )\n    }\n    throw new Error('Block not found!')\n  }\n\n  // If not inline, it's either a block (text) or a block object (non-text)\n  // NOTE: text blocks aren't draggable with DraggableBlock (yet?)\n  if (element._type === schemaTypes.block.name) {\n    className = `pt-block pt-text-block`\n    const isListItem = 'listItem' in element\n    if (debugRenders) {\n      debug(`Render ${element._key} (text block)`)\n    }\n    const style = ('style' in element && element.style) || 'normal'\n    className = `pt-block pt-text-block pt-text-block-style-${style}`\n    const blockStyleType = schemaTypes.styles.find(\n      (item) => item.value === style,\n    )\n    if (renderStyle && blockStyleType) {\n      renderedBlock = renderStyle({\n        block: element as PortableTextTextBlock,\n        children,\n        focused,\n        selected,\n        value: style,\n        path: blockPath,\n        schemaType: blockStyleType,\n        editorElementRef: blockRef,\n      })\n    }\n    let level: number | undefined\n\n    if (isListItem) {\n      if (typeof element.level === 'number') {\n        level = element.level\n      }\n      className += ` pt-list-item pt-list-item-${element.listItem} pt-list-item-level-${level || 1}`\n    }\n\n    if (editor.isListBlock(value) && isListItem && element.listItem) {\n      const listType = schemaTypes.lists.find(\n        (item) => item.value === element.listItem,\n      )\n      if (renderListItem && listType) {\n        renderedBlock = renderListItem({\n          block: value,\n          children: renderedBlock,\n          focused,\n          selected,\n          value: element.listItem,\n          path: blockPath,\n          schemaType: listType,\n          level: value.level || 1,\n          editorElementRef: blockRef,\n        })\n      }\n    }\n\n    const renderProps: Omit<BlockRenderProps, 'type'> = Object.defineProperty(\n      {\n        children: renderedBlock,\n        editorElementRef: blockRef,\n        focused,\n        level,\n        listItem: isListItem ? element.listItem : undefined,\n        path: blockPath,\n        selected,\n        style,\n        schemaType: schemaTypes.block,\n        value,\n      },\n      'type',\n      {\n        enumerable: false,\n        get() {\n          console.warn(\n            \"Property 'type' is deprecated, use 'schemaType' instead.\",\n          )\n          return schemaTypes.block\n        },\n      },\n    )\n\n    const propsOrDefaultRendered = renderBlock\n      ? renderBlock(renderProps as BlockRenderProps)\n      : children\n\n    return (\n      <div\n        key={element._key}\n        {...attributes}\n        className={className}\n        spellCheck={spellCheck}\n        {...droppable.droppableProps}\n      >\n        {droppable.isDraggingOverTop ? <DropIndicator /> : null}\n        <div ref={blockRef}>{propsOrDefaultRendered}</div>\n        {droppable.isDraggingOverBottom ? <DropIndicator /> : null}\n      </div>\n    )\n  }\n\n  const schemaType = schemaTypes.blockObjects.find(\n    (_type) => _type.name === element._type,\n  )\n\n  if (!schemaType) {\n    throw new Error(\n      `Could not find schema type for block element of _type ${element._type}`,\n    )\n  }\n\n  if (debugRenders) {\n    debug(`Render ${element._key} (object block)`)\n  }\n\n  className = 'pt-block pt-object-block'\n\n  const block = fromSlateValue(\n    [element],\n    schemaTypes.block.name,\n    KEY_TO_VALUE_ELEMENT.get(editor),\n  )[0]\n\n  let renderedBlockFromProps: JSX.Element | undefined\n\n  if (renderBlock) {\n    const _props: Omit<BlockRenderProps, 'type'> = Object.defineProperty(\n      {\n        children: <DefaultBlockObject value={value} />,\n        editorElementRef: blockRef,\n        focused,\n        path: blockPath,\n        schemaType,\n        selected,\n        value: block,\n      },\n      'type',\n      {\n        enumerable: false,\n        get() {\n          console.warn(\n            \"Property 'type' is deprecated, use 'schemaType' instead.\",\n          )\n          return schemaType\n        },\n      },\n    )\n    renderedBlockFromProps = renderBlock(_props as BlockRenderProps)\n  }\n\n  return (\n    <div\n      key={element._key}\n      {...attributes}\n      className={className}\n      {...droppable.droppableProps}\n      {...draggable.draggableProps}\n    >\n      {droppable.isDraggingOverTop ? <DropIndicator /> : null}\n      {children}\n      <div ref={blockRef} contentEditable={false}>\n        {renderedBlockFromProps ? (\n          renderedBlockFromProps\n        ) : (\n          <DefaultBlockObject value={value} />\n        )}\n      </div>\n      {droppable.isDraggingOverBottom ? <DropIndicator /> : null}\n    </div>\n  )\n}\n\nElement.displayName = 'Element'\n","import type {\n  Path,\n  PortableTextObject,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport {isEqual, uniq} from 'lodash'\nimport {\n  startTransition,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type ReactElement,\n} from 'react'\nimport {Text} from 'slate'\nimport {useSelected, type RenderLeafProps} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport type {\n  BlockAnnotationRenderProps,\n  BlockChildRenderProps,\n  BlockDecoratorRenderProps,\n  PortableTextMemberSchemaTypes,\n  RenderAnnotationFunction,\n  RenderChildFunction,\n  RenderDecoratorFunction,\n} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\nimport {usePortableTextEditor} from '../hooks/usePortableTextEditor'\nimport {PortableTextEditor} from '../PortableTextEditor'\n\nconst debug = debugWithName('components:Leaf')\n\nconst EMPTY_MARKS: string[] = []\n\n/**\n * @internal\n */\nexport interface LeafProps extends RenderLeafProps {\n  editorActor: EditorActor\n  children: ReactElement<any>\n  schemaTypes: PortableTextMemberSchemaTypes\n  renderAnnotation?: RenderAnnotationFunction\n  renderChild?: RenderChildFunction\n  renderDecorator?: RenderDecoratorFunction\n  readOnly: boolean\n}\n\n/**\n * Renders Portable Text span nodes in Slate\n * @internal\n */\nexport const Leaf = (props: LeafProps) => {\n  const {\n    editorActor,\n    attributes,\n    children,\n    leaf,\n    schemaTypes,\n    renderChild,\n    renderDecorator,\n    renderAnnotation,\n  } = props\n  const spanRef = useRef<HTMLElement>(null)\n  const portableTextEditor = usePortableTextEditor()\n  const blockSelected = useSelected()\n  const [focused, setFocused] = useState(false)\n  const [selected, setSelected] = useState(false)\n  const block = children.props.parent as PortableTextTextBlock | undefined\n  const path: Path = useMemo(\n    () => (block ? [{_key: block?._key}, 'children', {_key: leaf._key}] : []),\n    [block, leaf._key],\n  )\n  const decoratorValues = useMemo(\n    () => schemaTypes.decorators.map((dec) => dec.value),\n    [schemaTypes.decorators],\n  )\n  const marks: string[] = useMemo(\n    () =>\n      uniq(\n        (leaf.marks || EMPTY_MARKS).filter((mark) =>\n          decoratorValues.includes(mark),\n        ),\n      ),\n    [decoratorValues, leaf.marks],\n  )\n  const annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS\n  const annotations = useMemo(\n    () =>\n      annotationMarks\n        .map(\n          (mark) =>\n            !decoratorValues.includes(mark) &&\n            block?.markDefs?.find((def) => def._key === mark),\n        )\n        .filter(Boolean) as PortableTextObject[],\n    [annotationMarks, block, decoratorValues],\n  )\n\n  const shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected\n\n  useEffect(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      setFocused(false)\n      return\n    }\n    const sel = PortableTextEditor.getSelection(portableTextEditor)\n    if (\n      sel &&\n      isEqual(sel.focus.path, path) &&\n      PortableTextEditor.isCollapsedSelection(portableTextEditor)\n    ) {\n      startTransition(() => {\n        setFocused(true)\n      })\n    }\n  }, [shouldTrackSelectionAndFocus, path, portableTextEditor])\n\n  // Function to check if this leaf is currently inside the user's text selection\n  const setSelectedFromRange = useCallback(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      return\n    }\n    debug('Setting selection and focus from range')\n    const winSelection = window.getSelection()\n    if (!winSelection) {\n      setSelected(false)\n      return\n    }\n    if (winSelection && winSelection.rangeCount > 0) {\n      const range = winSelection.getRangeAt(0)\n      if (spanRef.current && range.intersectsNode(spanRef.current)) {\n        setSelected(true)\n      } else {\n        setSelected(false)\n      }\n    } else {\n      setSelected(false)\n    }\n  }, [shouldTrackSelectionAndFocus])\n\n  useEffect(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      return undefined\n    }\n\n    const onBlur = editorActor.on('blur', () => {\n      setFocused(false)\n      setSelected(false)\n    })\n\n    const onFocus = editorActor.on('focus', () => {\n      const sel = PortableTextEditor.getSelection(portableTextEditor)\n      if (\n        sel &&\n        isEqual(sel.focus.path, path) &&\n        PortableTextEditor.isCollapsedSelection(portableTextEditor)\n      ) {\n        setFocused(true)\n      }\n      setSelectedFromRange()\n    })\n\n    const onSelection = editorActor.on('selection', (event) => {\n      if (\n        event.selection &&\n        isEqual(event.selection.focus.path, path) &&\n        PortableTextEditor.isCollapsedSelection(portableTextEditor)\n      ) {\n        setFocused(true)\n      } else {\n        setFocused(false)\n      }\n      setSelectedFromRange()\n    })\n\n    return () => {\n      onBlur.unsubscribe()\n      onFocus.unsubscribe()\n      onSelection.unsubscribe()\n    }\n  }, [\n    editorActor,\n    path,\n    portableTextEditor,\n    setSelectedFromRange,\n    shouldTrackSelectionAndFocus,\n  ])\n\n  useEffect(() => setSelectedFromRange(), [setSelectedFromRange])\n\n  const content = useMemo(() => {\n    let returnedChildren = children\n    // Render text nodes\n    if (Text.isText(leaf) && leaf._type === schemaTypes.span.name) {\n      marks.forEach((mark) => {\n        const schemaType = schemaTypes.decorators.find(\n          (dec) => dec.value === mark,\n        )\n        if (schemaType && renderDecorator) {\n          const _props: Omit<BlockDecoratorRenderProps, 'type'> =\n            Object.defineProperty(\n              {\n                children: returnedChildren,\n                editorElementRef: spanRef,\n                focused,\n                path,\n                selected,\n                schemaType,\n                value: mark,\n              },\n              'type',\n              {\n                enumerable: false,\n                get() {\n                  console.warn(\n                    \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                  )\n                  return schemaType\n                },\n              },\n            )\n          returnedChildren = renderDecorator(\n            _props as BlockDecoratorRenderProps,\n          )\n        }\n      })\n\n      if (block && annotations.length > 0) {\n        annotations.forEach((annotation) => {\n          const schemaType = schemaTypes.annotations.find(\n            (t) => t.name === annotation._type,\n          )\n          if (schemaType) {\n            if (renderAnnotation) {\n              const _props: Omit<BlockAnnotationRenderProps, 'type'> =\n                Object.defineProperty(\n                  {\n                    block,\n                    children: returnedChildren,\n                    editorElementRef: spanRef,\n                    focused,\n                    path,\n                    selected,\n                    schemaType,\n                    value: annotation,\n                  },\n                  'type',\n                  {\n                    enumerable: false,\n                    get() {\n                      console.warn(\n                        \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                      )\n                      return schemaType\n                    },\n                  },\n                )\n\n              returnedChildren = (\n                <span ref={spanRef}>\n                  {renderAnnotation(_props as BlockAnnotationRenderProps)}\n                </span>\n              )\n            } else {\n              returnedChildren = <span ref={spanRef}>{returnedChildren}</span>\n            }\n          }\n        })\n      }\n      if (block && renderChild) {\n        const child = block.children.find((_child) => _child._key === leaf._key) // Ensure object equality\n        if (child) {\n          const defaultRendered = <>{returnedChildren}</>\n          const _props: Omit<BlockChildRenderProps, 'type'> =\n            Object.defineProperty(\n              {\n                annotations,\n                children: defaultRendered,\n                editorElementRef: spanRef,\n                focused,\n                path,\n                schemaType: schemaTypes.span,\n                selected,\n                value: child,\n              },\n              'type',\n              {\n                enumerable: false,\n                get() {\n                  console.warn(\n                    \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                  )\n                  return schemaTypes.span\n                },\n              },\n            )\n          returnedChildren = renderChild(_props as BlockChildRenderProps)\n        }\n      }\n    }\n    return returnedChildren\n  }, [\n    annotations,\n    block,\n    children,\n    focused,\n    leaf,\n    marks,\n    path,\n    renderAnnotation,\n    renderChild,\n    renderDecorator,\n    schemaTypes.annotations,\n    schemaTypes.decorators,\n    schemaTypes.span,\n    selected,\n  ])\n  return useMemo(\n    () => (\n      <span key={leaf._key} {...attributes} ref={spanRef}>\n        {content}\n      </span>\n    ),\n    [leaf, attributes, content],\n  )\n}\n\nLeaf.displayName = 'Leaf'\n","import type {KeyboardEvent} from 'react'\nimport type {ReactEditor} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {isHotkey} from '../../internal-utils/is-hotkey'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {HotkeyOptions} from '../../types/options'\nimport type {EditorActor} from '../editor-machine'\nimport type {PortableTextEditor} from '../PortableTextEditor'\n\nconst debug = debugWithName('plugin:withHotKeys')\n\n/**\n * This plugin takes care of all hotkeys in the editor\n *\n */\nexport function createWithHotkeys(\n  editorActor: EditorActor,\n  portableTextEditor: PortableTextEditor,\n  hotkeysFromOptions?: HotkeyOptions,\n): (editor: PortableTextSlateEditor & ReactEditor) => any {\n  const reservedHotkeys = ['enter', 'tab', 'shift', 'delete', 'end']\n  const activeHotkeys = hotkeysFromOptions ?? {}\n  return function withHotKeys(editor: PortableTextSlateEditor & ReactEditor) {\n    editor.pteWithHotKeys = (event: KeyboardEvent<HTMLDivElement>): void => {\n      // Wire up custom marks hotkeys\n      Object.keys(activeHotkeys).forEach((cat) => {\n        if (cat === 'marks') {\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey)) {\n              throw new Error(`The hotkey ${hotkey} is reserved!`)\n            }\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              event.preventDefault()\n              const possibleMark = activeHotkeys[cat]\n              if (possibleMark) {\n                const mark = possibleMark[hotkey]\n                debug(`HotKey ${hotkey} to toggle ${mark}`)\n                editorActor.send({\n                  type: 'behavior event',\n                  behaviorEvent: {\n                    type: 'decorator.toggle',\n                    decorator: mark,\n                  },\n                  editor,\n                })\n              }\n            }\n          }\n        }\n        if (cat === 'custom') {\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey)) {\n              throw new Error(`The hotkey ${hotkey} is reserved!`)\n            }\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              const possibleCommand = activeHotkeys[cat]\n              if (possibleCommand) {\n                const command = possibleCommand[hotkey]\n                command(event, portableTextEditor)\n              }\n            }\n          }\n        }\n      })\n    }\n    return editor\n  }\n}\n","import type {BaseEditor, Operation} from 'slate'\nimport type {ReactEditor} from 'slate-react'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport type {EditorActor} from './editor-machine'\n\n// React Compiler considers `slateEditor` as immutable, and opts-out if we do this inline in a useEffect, doing it in a function moves it out of the scope, and opts-in again for the rest of the component.\nexport function withSyncRangeDecorations({\n  editorActor,\n  slateEditor,\n  syncRangeDecorations,\n}: {\n  editorActor: EditorActor\n  slateEditor: BaseEditor & ReactEditor & PortableTextSlateEditor\n  syncRangeDecorations: (operation?: Operation) => void\n}) {\n  const originalApply = slateEditor.apply\n\n  slateEditor.apply = (op: Operation) => {\n    originalApply(op)\n\n    if (\n      !editorActor.getSnapshot().matches({'edit mode': 'read only'}) &&\n      op.type !== 'set_selection'\n    ) {\n      syncRangeDecorations(op)\n    }\n  }\n\n  return () => {\n    slateEditor.apply = originalApply\n  }\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport {useSelector} from '@xstate/react'\nimport {isEqual, noop} from 'lodash'\nimport {\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n  type ClipboardEvent,\n  type CSSProperties,\n  type FocusEventHandler,\n  type KeyboardEvent,\n  type MutableRefObject,\n  type TextareaHTMLAttributes,\n} from 'react'\nimport {\n  Editor,\n  Node,\n  Path,\n  Range as SlateRange,\n  Transforms,\n  type BaseRange,\n  type NodeEntry,\n  type Operation,\n  type Text,\n} from 'slate'\nimport {\n  ReactEditor,\n  Editable as SlateEditable,\n  useSlate,\n  type RenderElementProps,\n  type RenderLeafProps,\n} from 'slate-react'\nimport {debugWithName} from '../internal-utils/debug'\nimport {\n  moveRangeByOperation,\n  toPortableTextRange,\n  toSlateRange,\n} from '../internal-utils/ranges'\nimport {normalizeSelection} from '../internal-utils/selection'\nimport {\n  fromSlateValue,\n  isEqualToEmptyEditor,\n  toSlateValue,\n} from '../internal-utils/values'\nimport type {\n  EditorSelection,\n  OnCopyFn,\n  OnPasteFn,\n  RangeDecoration,\n  RenderAnnotationFunction,\n  RenderBlockFunction,\n  RenderChildFunction,\n  RenderDecoratorFunction,\n  RenderListItemFunction,\n  RenderPlaceholderFunction,\n  RenderStyleFunction,\n  ScrollSelectionIntoViewFunction,\n} from '../types/editor'\nimport type {HotkeyOptions} from '../types/options'\nimport type {SlateTextBlock, VoidElement} from '../types/slate'\nimport {Element} from './components/Element'\nimport {Leaf} from './components/Leaf'\nimport {EditorActorContext} from './editor-actor-context'\nimport {usePortableTextEditor} from './hooks/usePortableTextEditor'\nimport {createWithHotkeys} from './plugins/createWithHotKeys'\nimport {PortableTextEditor} from './PortableTextEditor'\nimport {withSyncRangeDecorations} from './withSyncRangeDecorations'\n\nconst debug = debugWithName('component:Editable')\n\nconst PLACEHOLDER_STYLE: CSSProperties = {\n  position: 'absolute',\n  userSelect: 'none',\n  pointerEvents: 'none',\n  left: 0,\n  right: 0,\n}\n\ninterface BaseRangeWithDecoration extends BaseRange {\n  rangeDecoration: RangeDecoration\n}\n\n/**\n * @public\n */\nexport type PortableTextEditableProps = Omit<\n  TextareaHTMLAttributes<HTMLDivElement>,\n  'onPaste' | 'onCopy' | 'onBeforeInput'\n> & {\n  hotkeys?: HotkeyOptions\n  onBeforeInput?: (event: InputEvent) => void\n  onPaste?: OnPasteFn\n  onCopy?: OnCopyFn\n  ref: MutableRefObject<HTMLDivElement | null>\n  rangeDecorations?: RangeDecoration[]\n  renderAnnotation?: RenderAnnotationFunction\n  renderBlock?: RenderBlockFunction\n  renderChild?: RenderChildFunction\n  renderDecorator?: RenderDecoratorFunction\n  renderListItem?: RenderListItemFunction\n  renderPlaceholder?: RenderPlaceholderFunction\n  renderStyle?: RenderStyleFunction\n  scrollSelectionIntoView?: ScrollSelectionIntoViewFunction\n  selection?: EditorSelection\n  spellCheck?: boolean\n}\n\n/**\n * @public\n *\n *\n * The core component that renders the editor. Must be placed within the {@link EditorProvider} component.\n *\n * @example\n * ```tsx\n * import { PortableTextEditable, EditorProvider } from '@portabletext/editor'\n *\n * function MyComponent() {\n *  return (\n *   <EditorProvider>\n *    <PortableTextEditable />\n *  </EditorProvider>\n *  )\n * }\n * ```\n * @group Components\n */\nexport const PortableTextEditable = forwardRef<\n  Omit<HTMLDivElement, 'as' | 'onPaste' | 'onBeforeInput'>,\n  PortableTextEditableProps\n>(function PortableTextEditable(props, forwardedRef) {\n  const {\n    hotkeys,\n    onBlur,\n    onFocus,\n    onBeforeInput,\n    onPaste,\n    onCopy,\n    onClick,\n    rangeDecorations,\n    renderAnnotation,\n    renderBlock,\n    renderChild,\n    renderDecorator,\n    renderListItem,\n    renderPlaceholder,\n    renderStyle,\n    selection: propsSelection,\n    scrollSelectionIntoView,\n    spellCheck,\n    ...restProps\n  } = props\n\n  const portableTextEditor = usePortableTextEditor()\n  const ref = useRef<HTMLDivElement | null>(null)\n  const [editableElement, setEditableElement] = useState<HTMLDivElement | null>(\n    null,\n  )\n  const [hasInvalidValue, setHasInvalidValue] = useState(false)\n  const [rangeDecorationState, setRangeDecorationsState] = useState<\n    BaseRangeWithDecoration[]\n  >([])\n\n  // Forward ref to parent component\n  useImperativeHandle<HTMLDivElement | null, HTMLDivElement | null>(\n    forwardedRef,\n    () => ref.current,\n  )\n\n  const rangeDecorationsRef = useRef(rangeDecorations)\n\n  const editorActor = useContext(EditorActorContext)\n  const readOnly = useSelector(editorActor, (s) =>\n    s.matches({'edit mode': 'read only'}),\n  )\n  const schemaTypes = useSelector(editorActor, (s) => s.context.schema)\n  const slateEditor = useSlate()\n\n  const blockTypeName = schemaTypes.block.name\n\n  // Output a minimal React editor inside Editable when in readOnly mode.\n  // NOTE: make sure all the plugins used here can be safely run over again at any point.\n  // There will be a problem if they redefine editor methods and then calling the original method within themselves.\n  useMemo(() => {\n    // React/UI-specific plugins\n    if (readOnly) {\n      debug('Editable is in read only mode')\n      return slateEditor\n    }\n    const withHotKeys = createWithHotkeys(\n      editorActor,\n      portableTextEditor,\n      hotkeys,\n    )\n\n    debug('Editable is in edit mode')\n    return withHotKeys(slateEditor)\n  }, [editorActor, hotkeys, portableTextEditor, readOnly, slateEditor])\n\n  const renderElement = useCallback(\n    (eProps: RenderElementProps) => (\n      <Element\n        {...eProps}\n        readOnly={readOnly}\n        renderBlock={renderBlock}\n        renderChild={renderChild}\n        renderListItem={renderListItem}\n        renderStyle={renderStyle}\n        schemaTypes={schemaTypes}\n        spellCheck={spellCheck}\n      />\n    ),\n    [\n      schemaTypes,\n      spellCheck,\n      readOnly,\n      renderBlock,\n      renderChild,\n      renderListItem,\n      renderStyle,\n    ],\n  )\n\n  const renderLeaf = useCallback(\n    (\n      lProps: RenderLeafProps & {\n        leaf: Text & {placeholder?: boolean; rangeDecoration?: RangeDecoration}\n      },\n    ) => {\n      if (lProps.leaf._type === 'span') {\n        let rendered = (\n          <Leaf\n            {...lProps}\n            editorActor={editorActor}\n            schemaTypes={schemaTypes}\n            renderAnnotation={renderAnnotation}\n            renderChild={renderChild}\n            renderDecorator={renderDecorator}\n            readOnly={readOnly}\n          />\n        )\n        if (\n          renderPlaceholder &&\n          lProps.leaf.placeholder &&\n          lProps.text.text === ''\n        ) {\n          return (\n            <>\n              <span style={PLACEHOLDER_STYLE} contentEditable={false}>\n                {renderPlaceholder()}\n              </span>\n              {rendered}\n            </>\n          )\n        }\n        const decoration = lProps.leaf.rangeDecoration\n        if (decoration) {\n          rendered = decoration.component({children: rendered})\n        }\n        return rendered\n      }\n      return lProps.children\n    },\n    [\n      editorActor,\n      readOnly,\n      renderAnnotation,\n      renderChild,\n      renderDecorator,\n      renderPlaceholder,\n      schemaTypes,\n    ],\n  )\n\n  const restoreSelectionFromProps = useCallback(() => {\n    if (propsSelection) {\n      debug(`Selection from props ${JSON.stringify(propsSelection)}`)\n      const normalizedSelection = normalizeSelection(\n        propsSelection,\n        fromSlateValue(slateEditor.children, blockTypeName),\n      )\n      if (normalizedSelection !== null) {\n        debug(\n          `Normalized selection from props ${JSON.stringify(normalizedSelection)}`,\n        )\n        const slateRange = toSlateRange(normalizedSelection, slateEditor)\n        if (slateRange) {\n          Transforms.select(slateEditor, slateRange)\n          // Output selection here in those cases where the editor selection was the same, and there are no set_selection operations made.\n          // The selection is usually automatically emitted to change$ by the withPortableTextSelections plugin whenever there is a set_selection operation applied.\n          if (!slateEditor.operations.some((o) => o.type === 'set_selection')) {\n            editorActor.send({\n              type: 'notify.selection',\n              selection: normalizedSelection,\n            })\n          }\n          slateEditor.onChange()\n        }\n      }\n    }\n  }, [blockTypeName, editorActor, propsSelection, slateEditor])\n\n  const syncRangeDecorations = useCallback(\n    (operation?: Operation) => {\n      if (rangeDecorations && rangeDecorations.length > 0) {\n        const newSlateRanges: BaseRangeWithDecoration[] = []\n        rangeDecorations.forEach((rangeDecorationItem) => {\n          const slateRange = toSlateRange(\n            rangeDecorationItem.selection,\n            slateEditor,\n          )\n          if (!SlateRange.isRange(slateRange)) {\n            if (rangeDecorationItem.onMoved) {\n              rangeDecorationItem.onMoved({\n                newSelection: null,\n                rangeDecoration: rangeDecorationItem,\n                origin: 'local',\n              })\n            }\n            return\n          }\n          let newRange: BaseRange | null | undefined\n          if (operation) {\n            newRange = moveRangeByOperation(slateRange, operation)\n            if (\n              (newRange && newRange !== slateRange) ||\n              (newRange === null && slateRange)\n            ) {\n              const value = PortableTextEditor.getValue(portableTextEditor)\n              const newRangeSelection = toPortableTextRange(\n                value,\n                newRange,\n                schemaTypes,\n              )\n              if (rangeDecorationItem.onMoved) {\n                rangeDecorationItem.onMoved({\n                  newSelection: newRangeSelection,\n                  rangeDecoration: rangeDecorationItem,\n                  origin: 'local',\n                })\n              }\n            }\n          }\n          // If the newRange is null, it means that the range is not valid anymore and should be removed\n          // If it's undefined, it means that the slateRange is still valid and should be kept\n          if (newRange !== null) {\n            newSlateRanges.push({\n              ...(newRange || slateRange),\n              rangeDecoration: rangeDecorationItem,\n            })\n          }\n        })\n        if (newSlateRanges.length > 0) {\n          setRangeDecorationsState(newSlateRanges)\n          return\n        }\n      }\n      setRangeDecorationsState((rangeDecorationState) => {\n        // If there's state then we want to reset\n        if (rangeDecorationState.length > 0) {\n          return []\n        }\n        // Otherwise we no-op, React will skip a state update if what we return has reference equality to the previous state\n        return rangeDecorationState\n      })\n    },\n    [portableTextEditor, rangeDecorations, schemaTypes, slateEditor],\n  )\n\n  // Restore selection from props when the editor has been initialized properly with it's value\n  useEffect(() => {\n    const onReady = editorActor.on('ready', () => {\n      syncRangeDecorations()\n      restoreSelectionFromProps()\n    })\n    const onInvalidValue = editorActor.on('invalid value', () => {\n      setHasInvalidValue(true)\n    })\n    const onValueChanged = editorActor.on('value changed', () => {\n      setHasInvalidValue(false)\n    })\n\n    return () => {\n      onReady.unsubscribe()\n      onInvalidValue.unsubscribe()\n      onValueChanged.unsubscribe()\n    }\n  }, [editorActor, restoreSelectionFromProps, syncRangeDecorations])\n\n  // Restore selection from props when it changes\n  useEffect(() => {\n    if (propsSelection && !hasInvalidValue) {\n      restoreSelectionFromProps()\n    }\n  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps])\n\n  const [syncedRangeDecorations, setSyncedRangeDecorations] = useState(false)\n  useEffect(() => {\n    if (!syncedRangeDecorations) {\n      // We only want this to run once, on mount\n      setSyncedRangeDecorations(true)\n      syncRangeDecorations()\n    }\n  }, [syncRangeDecorations, syncedRangeDecorations])\n\n  useEffect(() => {\n    if (!isEqual(rangeDecorations, rangeDecorationsRef.current)) {\n      syncRangeDecorations()\n    }\n    rangeDecorationsRef.current = rangeDecorations\n  }, [rangeDecorations, syncRangeDecorations])\n\n  // Sync range decorations after an operation is applied\n  useEffect(() => {\n    const teardown = withSyncRangeDecorations({\n      editorActor,\n      slateEditor,\n      syncRangeDecorations,\n    })\n    return () => teardown()\n  }, [editorActor, slateEditor, syncRangeDecorations])\n\n  // Handle from props onCopy function\n  const handleCopy = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>): void | ReactEditor => {\n      if (onCopy) {\n        const result = onCopy(event)\n        // CopyFn may return something to avoid doing default stuff\n        if (result !== undefined) {\n          event.preventDefault()\n        }\n      } else if (event.nativeEvent.clipboardData) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'copy',\n            data: event.nativeEvent.clipboardData,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onCopy, editorActor, slateEditor],\n  )\n\n  // Handle incoming pasting events in the editor\n  const handlePaste = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>): Promise<void> | void => {\n      const value = PortableTextEditor.getValue(portableTextEditor)\n      const ptRange = toPortableTextRange(\n        value,\n        slateEditor.selection,\n        schemaTypes,\n      )\n      const path = ptRange?.focus.path || []\n      const onPasteResult = onPaste?.({event, value, path, schemaTypes})\n\n      if (onPasteResult || !slateEditor.selection) {\n        event.preventDefault()\n\n        // Resolve it as promise (can be either async promise or sync return value)\n        editorActor.send({type: 'notify.loading'})\n\n        Promise.resolve(onPasteResult)\n          .then((result) => {\n            debug('Custom paste function from client resolved', result)\n\n            if (!result || !result.insert) {\n              debug('No result from custom paste handler, pasting normally')\n\n              slateEditor.insertData(event.clipboardData)\n            } else if (result.insert) {\n              slateEditor.insertFragment(\n                toSlateValue(result.insert as PortableTextBlock[], {\n                  schemaTypes,\n                }),\n              )\n            } else {\n              console.warn(\n                'Your onPaste function returned something unexpected:',\n                result,\n              )\n            }\n          })\n          .catch((error) => {\n            console.error(error)\n\n            return error\n          })\n          .finally(() => {\n            editorActor.send({type: 'notify.done loading'})\n          })\n      } else if (event.nativeEvent.clipboardData) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'paste',\n            data: event.nativeEvent.clipboardData,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n\n      debug('No result from custom paste handler, pasting normally')\n    },\n    [editorActor, onPaste, portableTextEditor, schemaTypes, slateEditor],\n  )\n\n  const handleOnFocus: FocusEventHandler<HTMLDivElement> = useCallback(\n    (event) => {\n      if (onFocus) {\n        onFocus(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        const selection = PortableTextEditor.getSelection(portableTextEditor)\n        // Create an editor selection if it does'nt exist\n        if (selection === null) {\n          Transforms.select(slateEditor, Editor.start(slateEditor, []))\n          slateEditor.onChange()\n        }\n        editorActor.send({type: 'notify.focused', event})\n        const newSelection = PortableTextEditor.getSelection(portableTextEditor)\n        // If the selection is the same, emit it explicitly here as there is no actual onChange event triggered.\n        if (selection === newSelection) {\n          editorActor.send({\n            type: 'notify.selection',\n            selection,\n          })\n        }\n      }\n    },\n    [editorActor, onFocus, portableTextEditor, slateEditor],\n  )\n\n  const handleClick = useCallback(\n    (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n      if (onClick) {\n        onClick(event)\n      }\n\n      const focusBlockPath = slateEditor.selection\n        ? slateEditor.selection.focus.path.slice(0, 1)\n        : undefined\n      const focusBlock = focusBlockPath\n        ? (Node.descendant(slateEditor, focusBlockPath) as\n            | SlateTextBlock\n            | VoidElement)\n        : undefined\n      const [_, lastNodePath] = Node.last(slateEditor, [])\n      const lastBlockPath = lastNodePath.slice(0, 1)\n      const lastNodeFocused = focusBlockPath\n        ? Path.equals(lastBlockPath, focusBlockPath)\n        : false\n      const lastBlockIsVoid = focusBlock\n        ? !slateEditor.isTextBlock(focusBlock)\n        : false\n      const collapsedSelection =\n        slateEditor.selection && SlateRange.isCollapsed(slateEditor.selection)\n\n      if (collapsedSelection && lastNodeFocused && lastBlockIsVoid) {\n        Transforms.insertNodes(\n          slateEditor,\n          slateEditor.pteCreateTextBlock({decorators: []}),\n        )\n        slateEditor.onChange()\n      }\n    },\n    [onClick, slateEditor],\n  )\n\n  const handleOnBlur: FocusEventHandler<HTMLDivElement> = useCallback(\n    (event) => {\n      if (onBlur) {\n        onBlur(event)\n      }\n      if (!event.isPropagationStopped()) {\n        editorActor.send({type: 'notify.blurred', event})\n      }\n    },\n    [editorActor, onBlur],\n  )\n\n  const handleOnBeforeInput = useCallback(\n    (event: InputEvent) => {\n      if (onBeforeInput) {\n        onBeforeInput(event)\n      }\n    },\n    [onBeforeInput],\n  )\n\n  // This function will handle unexpected DOM changes inside the Editable rendering,\n  // and make sure that we can maintain a stable slateEditor.selection when that happens.\n  //\n  // For example, if this Editable is rendered inside something that might re-render\n  // this component (hidden contexts) while the user is still actively changing the\n  // contentEditable, this could interfere with the intermediate DOM selection,\n  // which again could be picked up by ReactEditor's event listeners.\n  // If that range is invalid at that point, the slate.editorSelection could be\n  // set either wrong, or invalid, to which slateEditor will throw exceptions\n  // that are impossible to recover properly from or result in a wrong selection.\n  //\n  // Also the other way around, when the ReactEditor will try to create a DOM Range\n  // from the current slateEditor.selection, it may throw unrecoverable errors\n  // if the current editor.selection is invalid according to the DOM.\n  // If this is the case, default to selecting the top of the document, if the\n  // user already had a selection.\n  const validateSelection = useCallback(() => {\n    if (!slateEditor.selection) {\n      return\n    }\n    const root = ReactEditor.findDocumentOrShadowRoot(slateEditor)\n    const {activeElement} = root\n    // Return if the editor isn't the active element\n    if (ref.current !== activeElement) {\n      return\n    }\n    const window = ReactEditor.getWindow(slateEditor)\n    const domSelection = window.getSelection()\n    if (!domSelection || domSelection.rangeCount === 0) {\n      return\n    }\n    const existingDOMRange = domSelection.getRangeAt(0)\n    try {\n      const newDOMRange = ReactEditor.toDOMRange(\n        slateEditor,\n        slateEditor.selection,\n      )\n      if (\n        newDOMRange.startOffset !== existingDOMRange.startOffset ||\n        newDOMRange.endOffset !== existingDOMRange.endOffset\n      ) {\n        debug('DOM range out of sync, validating selection')\n        // Remove all ranges temporary\n        domSelection?.removeAllRanges()\n        // Set the correct range\n        domSelection.addRange(newDOMRange)\n      }\n    } catch {\n      debug(`Could not resolve selection, selecting top document`)\n      // Deselect the editor\n      Transforms.deselect(slateEditor)\n      // Select top document if there is a top block to select\n      if (slateEditor.children.length > 0) {\n        Transforms.select(slateEditor, [0, 0])\n      }\n      slateEditor.onChange()\n    }\n  }, [ref, slateEditor])\n\n  // Observe mutations (child list and subtree) to this component's DOM,\n  // and make sure the editor selection is valid when that happens.\n  useEffect(() => {\n    if (editableElement) {\n      const mutationObserver = new MutationObserver(validateSelection)\n      mutationObserver.observe(editableElement, {\n        attributeOldValue: false,\n        attributes: false,\n        characterData: false,\n        childList: true,\n        subtree: true,\n      })\n      return () => {\n        mutationObserver.disconnect()\n      }\n    }\n    return undefined\n  }, [validateSelection, editableElement])\n\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent<HTMLDivElement>) => {\n      if (props.onKeyDown) {\n        props.onKeyDown(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        slateEditor.pteWithHotKeys(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'key.down',\n            keyboardEvent: {\n              key: event.key,\n              code: event.code,\n              altKey: event.altKey,\n              ctrlKey: event.ctrlKey,\n              metaKey: event.metaKey,\n              shiftKey: event.shiftKey,\n            },\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [props, editorActor, slateEditor],\n  )\n\n  const handleKeyUp = useCallback(\n    (event: KeyboardEvent<HTMLDivElement>) => {\n      if (props.onKeyUp) {\n        props.onKeyUp(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'key.up',\n            keyboardEvent: {\n              key: event.key,\n              code: event.code,\n              altKey: event.altKey,\n              ctrlKey: event.ctrlKey,\n              metaKey: event.metaKey,\n              shiftKey: event.shiftKey,\n            },\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [props, editorActor, slateEditor],\n  )\n\n  const scrollSelectionIntoViewToSlate = useMemo(() => {\n    // Use slate-react default scroll into view\n    if (scrollSelectionIntoView === undefined) {\n      return undefined\n    }\n    // Disable scroll into view totally\n    if (scrollSelectionIntoView === null) {\n      return noop\n    }\n    // Translate PortableTextEditor prop fn to Slate plugin fn\n    return (_editor: ReactEditor, domRange: Range) => {\n      scrollSelectionIntoView(portableTextEditor, domRange)\n    }\n  }, [portableTextEditor, scrollSelectionIntoView])\n\n  const decorate: (entry: NodeEntry) => BaseRange[] = useCallback(\n    ([, path]) => {\n      if (isEqualToEmptyEditor(slateEditor.children, schemaTypes)) {\n        return [\n          {\n            anchor: {\n              path: [0, 0],\n              offset: 0,\n            },\n            focus: {\n              path: [0, 0],\n              offset: 0,\n            },\n            placeholder: true,\n          },\n        ]\n      }\n      // Editor node has a path length of 0 (should never be decorated)\n      if (path.length === 0) {\n        return []\n      }\n      const result = rangeDecorationState.filter((item) => {\n        // Special case in order to only return one decoration for collapsed ranges\n        if (SlateRange.isCollapsed(item)) {\n          // Collapsed ranges should only be decorated if they are on a block child level (length 2)\n          if (path.length !== 2) {\n            return false\n          }\n          return (\n            Path.equals(item.focus.path, path) &&\n            Path.equals(item.anchor.path, path)\n          )\n        }\n        // Include decorations that either include or intersects with this path\n        return (\n          SlateRange.intersection(item, {\n            anchor: {path, offset: 0},\n            focus: {path, offset: 0},\n          }) || SlateRange.includes(item, path)\n        )\n      })\n      if (result.length > 0) {\n        return result\n      }\n      return []\n    },\n    [slateEditor, schemaTypes, rangeDecorationState],\n  )\n\n  // Set the forwarded ref to be the Slate editable DOM element\n  // Also set the editable element in a state so that the MutationObserver\n  // is setup when this element is ready.\n  useEffect(() => {\n    ref.current = ReactEditor.toDOMNode(\n      slateEditor,\n      slateEditor,\n    ) as HTMLDivElement | null\n    setEditableElement(ref.current)\n  }, [slateEditor, ref])\n\n  useEffect(() => {\n    const window = ReactEditor.getWindow(slateEditor)\n\n    const onDragEnd = () => {\n      editorActor.send({type: 'dragend'})\n    }\n    const onDrop = () => {\n      editorActor.send({type: 'drop'})\n    }\n\n    window.document.addEventListener('dragend', onDragEnd)\n    window.document.addEventListener('drop', onDrop)\n\n    return () => {\n      window.document.removeEventListener('dragend', onDragEnd)\n      window.document.removeEventListener('drop', onDrop)\n    }\n  }, [slateEditor, editorActor])\n\n  if (!portableTextEditor) {\n    return null\n  }\n  return hasInvalidValue ? null : (\n    <SlateEditable\n      {...restProps}\n      autoFocus={false}\n      className={restProps.className || 'pt-editable'}\n      decorate={decorate}\n      onBlur={handleOnBlur}\n      onCopy={handleCopy}\n      onClick={handleClick}\n      onDOMBeforeInput={handleOnBeforeInput}\n      onDragStart={(event) => {\n        props.onDragStart?.(event)\n\n        if (!event.isDefaultPrevented() && !event.isPropagationStopped()) {\n          editorActor.send({type: 'dragstart'})\n        }\n      }}\n      onFocus={handleOnFocus}\n      onKeyDown={handleKeyDown}\n      onKeyUp={handleKeyUp}\n      onPaste={handlePaste}\n      readOnly={readOnly}\n      // We have implemented our own placeholder logic with decorations.\n      // This 'renderPlaceholder' should not be used.\n      renderPlaceholder={undefined}\n      renderElement={renderElement}\n      renderLeaf={renderLeaf}\n      scrollSelectionIntoView={scrollSelectionIntoViewToSlate}\n    />\n  )\n})\n\nPortableTextEditable.displayName = 'ForwardRef(PortableTextEditable)'\n","import {useEffect} from 'react'\nimport {useEffectEvent} from 'use-effect-event'\nimport type {EditorEmittedEvent} from './editor/editor-machine'\nimport {useEditor} from './editor/editor-provider'\n\n/**\n * @public\n * @deprecated\n * This component has been renamed. Use `EventListenerPlugin` instead.\n *\n * ```\n * import {EventListenerPlugin} from '@portabletext/editor/plugins'\n * ```\n */\nexport function EditorEventListener(props: {\n  on: (event: EditorEmittedEvent) => void\n}) {\n  const editor = useEditor()\n  const on = useEffectEvent(props.on)\n\n  useEffect(() => {\n    const subscription = editor.on('*', on)\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [editor])\n\n  return null\n}\n"],"names":["normalizePoint","point","value","newPath","newOffset","offset","blockKey","path","_key","childKey","block","find","blk","push","children","Array","isArray","length","child","cld","text","normalizeSelection","selection","newAnchor","newFocus","anchor","focus","isEqual","backward","DefaultBlockObject","props","$","_c","t0","Symbol","for","userSelect","t1","_type","jsxs","DefaultInlineObject","DropIndicator","position","width","height","borderBottom","zIndex","debug","debugWithName","useDraggable","editor","useSlateStatic","dragGhostRef","useRef","undefined","blockElement","setBlockElement","useState","blockRef","element","current","ReactEditor","toDOMNode","useEffect","t2","event","targetBlock","IS_DRAGGING_ELEMENT_TARGET","get","set","preventDefault","stopPropagation","delete","document","body","removeChild","dragPosition","IS_DRAGGING_BLOCK_TARGET_POSITION","targetPath","findPath","myPath","isBefore","Path","originalPath","JSON","stringify","originalPath_0","equals","Transforms","moveNodes","at","to","onChange","handleDragEnd","t3","event_0","IS_DRAGGING_BLOCK_ELEMENT","target","HTMLElement","style","opacity","handleDrag","t4","event_1","IS_DRAGGING","dataTransfer","setData","effectAllowed","dragGhost","cloneNode","customGhost","querySelector","setAttribute","left","boxSizing","appendChild","rect","getBoundingClientRect","x","clientX","y","clientY","top","setDragImage","handleDragStart","readOnly","t5","draggableProps","draggable","onDragStart","onDrag","onDragEnd","useDroppable","isDragOver","setIsDragOver","isMyDragOver","dropEffect","elementRect","Y","pageY","loc","Math","abs","handleDragOver","handleDragLeave","handleDrop","isDraggingOverFirstBlock","t6","isDraggingOverLastBlock","isDraggingOverTop","isDraggingOverBottom","t7","droppableProps","onDragOver","onDragLeave","onDrop","t8","EMPTY_ANNOTATIONS","inlineBlockStyle","display","Element","attributes","schemaTypes","renderBlock","renderChild","renderListItem","renderStyle","spellCheck","selected","useSelected","inlineBlockObjectRef","focused","Range","isCollapsed","droppable","useMemo","fromSlateValue","name","KEY_TO_VALUE_ELEMENT","renderedBlock","className","blockPath","Error","isInline","Editor","node","depth","schemaType","inlineObjects","SlateElement","isElement","elmPath","debugRenders","annotations","jsx","editorElementRef","type","isListItem","blockStyleType","styles","item","level","listItem","isListBlock","listType","lists","renderProps","Object","defineProperty","enumerable","warn","propsOrDefaultRendered","blockObjects","renderedBlockFromProps","_props","displayName","EMPTY_MARKS","Leaf","editorActor","leaf","renderDecorator","renderAnnotation","spanRef","portableTextEditor","usePortableTextEditor","blockSelected","setFocused","setSelected","parent","decoratorValues","decorators","map","dec","marks","uniq","filter","mark","includes","annotationMarks","markDefs","def","Boolean","shouldTrackSelectionAndFocus","sel","PortableTextEditor","getSelection","isCollapsedSelection","startTransition","setSelectedFromRange","useCallback","winSelection","window","rangeCount","range","getRangeAt","intersectsNode","onBlur","on","onFocus","onSelection","unsubscribe","content","returnedChildren","Text","isText","span","forEach","annotation","t","_child","createWithHotkeys","hotkeysFromOptions","reservedHotkeys","activeHotkeys","pteWithHotKeys","keys","cat","hotkey","isHotkey","nativeEvent","possibleMark","send","behaviorEvent","decorator","possibleCommand","command","withSyncRangeDecorations","slateEditor","syncRangeDecorations","originalApply","apply","op","getSnapshot","matches","PLACEHOLDER_STYLE","pointerEvents","right","PortableTextEditable","forwardRef","forwardedRef","hotkeys","onBeforeInput","onPaste","onCopy","onClick","rangeDecorations","renderPlaceholder","propsSelection","scrollSelectionIntoView","restProps","ref","editableElement","setEditableElement","hasInvalidValue","setHasInvalidValue","rangeDecorationState","setRangeDecorationsState","rangeDecorationsRef","useContext","EditorActorContext","useSelector","s","context","schema","useSlate","blockTypeName","withHotKeys","renderElement","eProps","renderLeaf","lProps","rendered","placeholder","Fragment","decoration","rangeDecoration","component","restoreSelectionFromProps","normalizedSelection","slateRange","toSlateRange","select","operations","some","o","operation","newSlateRanges","rangeDecorationItem","SlateRange","isRange","onMoved","newSelection","origin","newRange","moveRangeByOperation","getValue","newRangeSelection","toPortableTextRange","onReady","onInvalidValue","onValueChanged","syncedRangeDecorations","setSyncedRangeDecorations","teardown","handleCopy","clipboardData","data","handlePaste","onPasteResult","Promise","resolve","then","result","insert","insertData","insertFragment","toSlateValue","console","catch","error","finally","handleOnFocus","isDefaultPrevented","start","handleClick","focusBlockPath","slice","focusBlock","Node","descendant","_","lastNodePath","last","lastBlockPath","lastNodeFocused","lastBlockIsVoid","isTextBlock","insertNodes","pteCreateTextBlock","handleOnBlur","isPropagationStopped","handleOnBeforeInput","validateSelection","root","findDocumentOrShadowRoot","activeElement","domSelection","getWindow","existingDOMRange","newDOMRange","toDOMRange","startOffset","endOffset","removeAllRanges","addRange","deselect","mutationObserver","MutationObserver","observe","attributeOldValue","characterData","childList","subtree","disconnect","handleKeyDown","onKeyDown","keyboardEvent","key","code","altKey","ctrlKey","metaKey","shiftKey","handleKeyUp","onKeyUp","scrollSelectionIntoViewToSlate","noop","_editor","domRange","decorate","isEqualToEmptyEditor","intersection","addEventListener","removeEventListener","SlateEditable","EditorEventListener","useEditor","useEffectEvent","subscription"],"mappings":"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"}