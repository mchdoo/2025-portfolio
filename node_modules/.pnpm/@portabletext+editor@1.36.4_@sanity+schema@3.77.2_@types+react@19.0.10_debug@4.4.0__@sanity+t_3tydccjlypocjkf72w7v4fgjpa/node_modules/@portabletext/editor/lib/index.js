import { debugWithName, IS_DRAGGING_ELEMENT_TARGET, IS_DRAGGING, IS_DRAGGING_BLOCK_TARGET_POSITION, IS_DRAGGING_BLOCK_ELEMENT, fromSlateValue, KEY_TO_VALUE_ELEMENT, usePortableTextEditor, PortableTextEditor, EditorActorContext, toSlateRange, moveRangeByOperation, toPortableTextRange, toSlateValue, isEqualToEmptyEditor, useEditor } from "./_chunks-es/editor-provider.js";
import { EditorProvider, defineSchema, defaultKeyGenerator, useEditorSelector, usePortableTextEditorSelection } from "./_chunks-es/editor-provider.js";
import { jsxs, jsx, Fragment } from "react/jsx-runtime";
import { useSelector } from "@xstate/react";
import isEqual from "lodash/isEqual.js";
import noop from "lodash/noop.js";
import { useRef, useState, useEffect, useMemo, startTransition, useCallback, forwardRef, useImperativeHandle, useContext } from "react";
import { Path, Transforms, Range, Editor, Element as Element$1, Text, Node } from "slate";
import { useSlateStatic, ReactEditor, useSelected, useSlate, Editable } from "slate-react";
import { c } from "react-compiler-runtime";
import uniq from "lodash/uniq.js";
import { isHotkey } from "./_chunks-es/behavior.core.js";
import { useEffectEvent } from "use-effect-event";
function normalizePoint(point, value) {
  if (!point || !value)
    return null;
  const newPath = [];
  let newOffset = point.offset || 0;
  const blockKey = typeof point.path[0] == "object" && "_key" in point.path[0] && point.path[0]._key, childKey = typeof point.path[2] == "object" && "_key" in point.path[2] && point.path[2]._key, block = value.find((blk) => blk._key === blockKey);
  if (block)
    newPath.push({
      _key: block._key
    });
  else
    return null;
  if (block && point.path[1] === "children") {
    if (!block.children || Array.isArray(block.children) && block.children.length === 0)
      return null;
    const child = Array.isArray(block.children) && block.children.find((cld) => cld._key === childKey);
    if (child)
      newPath.push("children"), newPath.push({
        _key: child._key
      }), newOffset = child.text && child.text.length >= point.offset ? point.offset : child.text && child.text.length || 0;
    else
      return null;
  }
  return {
    path: newPath,
    offset: newOffset
  };
}
function normalizeSelection(selection, value) {
  if (!selection || !value || value.length === 0)
    return null;
  let newAnchor = null, newFocus = null;
  const {
    anchor,
    focus
  } = selection;
  return anchor && value.find((blk) => isEqual({
    _key: blk._key
  }, anchor.path[0])) && (newAnchor = normalizePoint(anchor, value)), focus && value.find((blk) => isEqual({
    _key: blk._key
  }, focus.path[0])) && (newFocus = normalizePoint(focus, value)), newAnchor && newFocus ? {
    anchor: newAnchor,
    focus: newFocus,
    backward: selection.backward
  } : null;
}
function DefaultBlockObject(props) {
  const $ = c(4);
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    userSelect: "none"
  }, $[0] = t0) : t0 = $[0];
  let t1;
  return $[1] !== props.value._key || $[2] !== props.value._type ? (t1 = /* @__PURE__ */ jsxs("div", { style: t0, children: [
    "[",
    props.value._type,
    ": ",
    props.value._key,
    "]"
  ] }), $[1] = props.value._key, $[2] = props.value._type, $[3] = t1) : t1 = $[3], t1;
}
function DefaultInlineObject(props) {
  const $ = c(4);
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    userSelect: "none"
  }, $[0] = t0) : t0 = $[0];
  let t1;
  return $[1] !== props.value._key || $[2] !== props.value._type ? (t1 = /* @__PURE__ */ jsxs("span", { style: t0, children: [
    "[",
    props.value._type,
    ": ",
    props.value._key,
    "]"
  ] }), $[1] = props.value._key, $[2] = props.value._type, $[3] = t1) : t1 = $[3], t1;
}
function DropIndicator() {
  const $ = c(1);
  let t0;
  return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = /* @__PURE__ */ jsx("div", { className: "pt-drop-indicator", style: {
    position: "absolute",
    width: "100%",
    height: 1,
    borderBottom: "1px solid currentColor",
    zIndex: 5
  } }), $[0] = t0) : t0 = $[0], t0;
}
const debug$4 = debugWithName("useDraggable");
function useDraggable(props) {
  const $ = c(20), editor = useSlateStatic(), dragGhostRef = useRef(void 0), [blockElement, setBlockElement] = useState(null);
  let t0, t1;
  $[0] !== editor || $[1] !== props.blockRef || $[2] !== props.element ? (t0 = () => setBlockElement(props.blockRef ? props.blockRef.current : ReactEditor.toDOMNode(editor, props.element)), t1 = [editor, props.element, props.blockRef], $[0] = editor, $[1] = props.blockRef, $[2] = props.element, $[3] = t0, $[4] = t1) : (t0 = $[3], t1 = $[4]), useEffect(t0, t1);
  let t2;
  $[5] !== editor || $[6] !== props.element ? (t2 = (event) => {
    const targetBlock = IS_DRAGGING_ELEMENT_TARGET.get(editor);
    if (targetBlock) {
      IS_DRAGGING.set(editor, !1), event.preventDefault(), event.stopPropagation(), IS_DRAGGING_ELEMENT_TARGET.delete(editor), dragGhostRef.current && (debug$4("Removing drag ghost"), document.body.removeChild(dragGhostRef.current));
      const dragPosition = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);
      IS_DRAGGING_BLOCK_TARGET_POSITION.delete(editor);
      let targetPath = ReactEditor.findPath(editor, targetBlock);
      const myPath = ReactEditor.findPath(editor, props.element), isBefore = Path.isBefore(myPath, targetPath);
      if (dragPosition === "bottom" && !isBefore) {
        if (targetPath[0] >= editor.children.length - 1) {
          debug$4("target is already at the bottom, not moving");
          return;
        }
        const originalPath = targetPath;
        targetPath = Path.next(targetPath), debug$4(`Adjusting targetPath from ${JSON.stringify(originalPath)} to ${JSON.stringify(targetPath)}`);
      }
      if (dragPosition === "top" && isBefore && targetPath[0] !== editor.children.length - 1) {
        const originalPath_0 = targetPath;
        targetPath = Path.previous(targetPath), debug$4(`Adjusting targetPath from ${JSON.stringify(originalPath_0)} to ${JSON.stringify(targetPath)}`);
      }
      if (Path.equals(targetPath, myPath)) {
        event.preventDefault(), debug$4("targetPath and myPath is the same, not moving");
        return;
      }
      debug$4(`Moving element ${props.element._key} from path ${JSON.stringify(myPath)} to ${JSON.stringify(targetPath)} (${dragPosition})`), Transforms.moveNodes(editor, {
        at: myPath,
        to: targetPath
      }), editor.onChange();
      return;
    }
    debug$4("No target element, not doing anything");
  }, $[5] = editor, $[6] = props.element, $[7] = t2) : t2 = $[7];
  const handleDragEnd = t2;
  let t3;
  $[8] !== editor || $[9] !== props.element ? (t3 = (event_0) => {
    IS_DRAGGING.set(editor, !0), IS_DRAGGING_BLOCK_ELEMENT.set(editor, props.element), event_0.stopPropagation();
    const target = event_0.target;
    target instanceof HTMLElement && (target.style.opacity = "1");
  }, $[8] = editor, $[9] = props.element, $[10] = t3) : t3 = $[10];
  const handleDrag = t3;
  let t4;
  $[11] !== blockElement || $[12] !== editor || $[13] !== handleDrag ? (t4 = (event_1) => {
    if (debug$4("Drag start"), IS_DRAGGING.set(editor, !0), event_1.dataTransfer && (event_1.dataTransfer.setData("application/portable-text", "something"), event_1.dataTransfer.effectAllowed = "move"), blockElement && blockElement instanceof HTMLElement) {
      let dragGhost = blockElement.cloneNode(!0);
      const customGhost = dragGhost.querySelector("[data-pt-drag-ghost-element]");
      if (customGhost && (dragGhost = customGhost), dragGhost.setAttribute("data-dragged", ""), document.body) {
        dragGhostRef.current = dragGhost, dragGhost.style.position = "absolute", dragGhost.style.left = "-99999px", dragGhost.style.boxSizing = "border-box", document.body.appendChild(dragGhost);
        const rect = blockElement.getBoundingClientRect(), x = event_1.clientX - rect.left, y = event_1.clientY - rect.top;
        dragGhost.style.width = `${rect.width}px`, dragGhost.style.height = `${rect.height}px`, event_1.dataTransfer.setDragImage(dragGhost, x, y);
      }
    }
    handleDrag(event_1);
  }, $[11] = blockElement, $[12] = editor, $[13] = handleDrag, $[14] = t4) : t4 = $[14];
  const handleDragStart = t4;
  if (props.readOnly) {
    let t52;
    return $[15] === Symbol.for("react.memo_cache_sentinel") ? (t52 = {
      draggableProps: {
        draggable: !1,
        onDragStart: void 0,
        onDrag: void 0,
        onDragEnd: void 0
      }
    }, $[15] = t52) : t52 = $[15], t52;
  }
  let t5;
  return $[16] !== handleDrag || $[17] !== handleDragEnd || $[18] !== handleDragStart ? (t5 = {
    draggableProps: {
      draggable: !0,
      onDragStart: handleDragStart,
      onDrag: handleDrag,
      onDragEnd: handleDragEnd
    }
  }, $[16] = handleDrag, $[17] = handleDragEnd, $[18] = handleDragStart, $[19] = t5) : t5 = $[19], t5;
}
const debug$3 = debugWithName("useDroppable");
function useDroppable(props) {
  const $ = c(27), editor = useSlateStatic(), [isDragOver, setIsDragOver] = useState(!1), [blockElement, setBlockElement] = useState(null);
  let t0, t1;
  $[0] !== editor || $[1] !== props.blockRef || $[2] !== props.element ? (t0 = () => setBlockElement(props.blockRef ? props.blockRef.current : ReactEditor.toDOMNode(editor, props.element)), t1 = [editor, props.element, props.blockRef], $[0] = editor, $[1] = props.blockRef, $[2] = props.element, $[3] = t0, $[4] = t1) : (t0 = $[3], t1 = $[4]), useEffect(t0, t1);
  let t2;
  $[5] !== blockElement || $[6] !== editor || $[7] !== props.element ? (t2 = (event) => {
    const isMyDragOver = IS_DRAGGING_BLOCK_ELEMENT.get(editor);
    if (!isMyDragOver || !blockElement)
      return;
    event.preventDefault(), event.dataTransfer.dropEffect = "move", IS_DRAGGING_ELEMENT_TARGET.set(editor, props.element);
    const elementRect = blockElement.getBoundingClientRect(), offset = elementRect.top, height = elementRect.height, Y = event.pageY, loc = Math.abs(offset - Y);
    if (props.element === editor.children[0] || (loc < height / 2 ? IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, "top") : IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, "bottom")), isMyDragOver === props.element) {
      event.dataTransfer.dropEffect = "none";
      return;
    }
    setIsDragOver(!0);
  }, $[5] = blockElement, $[6] = editor, $[7] = props.element, $[8] = t2) : t2 = $[8];
  const handleDragOver = t2;
  let t3;
  $[9] === Symbol.for("react.memo_cache_sentinel") ? (t3 = () => {
    setIsDragOver(!1);
  }, $[9] = t3) : t3 = $[9];
  const handleDragLeave = t3;
  let t4;
  $[10] !== editor || $[11] !== props.element ? (t4 = (event_0) => {
    IS_DRAGGING_BLOCK_ELEMENT.get(editor) && (debug$3("On drop (prevented)", props.element), event_0.preventDefault(), event_0.stopPropagation(), setIsDragOver(!1));
  }, $[10] = editor, $[11] = props.element, $[12] = t4) : t4 = $[12];
  const handleDrop = t4;
  let t5;
  $[13] !== editor || $[14] !== isDragOver ? (t5 = isDragOver && editor.children[0] === IS_DRAGGING_ELEMENT_TARGET.get(editor), $[13] = editor, $[14] = isDragOver, $[15] = t5) : t5 = $[15];
  const isDraggingOverFirstBlock = t5;
  let t6;
  $[16] !== editor || $[17] !== isDragOver ? (t6 = isDragOver && editor.children[editor.children.length - 1] === IS_DRAGGING_ELEMENT_TARGET.get(editor), $[16] = editor, $[17] = isDragOver, $[18] = t6) : t6 = $[18];
  const isDraggingOverLastBlock = t6, dragPosition = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor), isDraggingOverTop = isDraggingOverFirstBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition === "top", isDraggingOverBottom = isDraggingOverLastBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition === "bottom";
  if (props.readOnly) {
    let t72;
    return $[19] === Symbol.for("react.memo_cache_sentinel") ? (t72 = {
      droppableProps: {
        onDragOver: void 0,
        onDragLeave: void 0,
        onDrop: void 0
      },
      isDraggingOverTop: !1,
      isDraggingOverBottom: !1
    }, $[19] = t72) : t72 = $[19], t72;
  }
  let t7;
  $[20] !== handleDragOver || $[21] !== handleDrop ? (t7 = {
    onDragOver: handleDragOver,
    onDragLeave: handleDragLeave,
    onDrop: handleDrop
  }, $[20] = handleDragOver, $[21] = handleDrop, $[22] = t7) : t7 = $[22];
  let t8;
  return $[23] !== isDraggingOverBottom || $[24] !== isDraggingOverTop || $[25] !== t7 ? (t8 = {
    droppableProps: t7,
    isDraggingOverTop,
    isDraggingOverBottom
  }, $[23] = isDraggingOverBottom, $[24] = isDraggingOverTop, $[25] = t7, $[26] = t8) : t8 = $[26], t8;
}
debugWithName("components:Element");
const EMPTY_ANNOTATIONS = [], inlineBlockStyle = {
  display: "inline-block"
}, Element = ({
  attributes,
  children,
  element,
  schemaTypes,
  readOnly,
  renderBlock,
  renderChild,
  renderListItem,
  renderStyle,
  spellCheck
}) => {
  const editor = useSlateStatic(), selected = useSelected(), blockRef = useRef(null), inlineBlockObjectRef = useRef(null), focused = selected && editor.selection && Range.isCollapsed(editor.selection) || !1, droppable = useDroppable({
    element,
    blockRef,
    readOnly
  }), draggable = useDraggable({
    element,
    blockRef,
    readOnly
  }), value = useMemo(() => fromSlateValue([element], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0], [editor, element, schemaTypes.block.name]);
  let renderedBlock = children, className;
  const blockPath = useMemo(() => [{
    _key: element._key
  }], [element]);
  if (typeof element._type != "string")
    throw new Error("Expected element to have a _type property");
  if (typeof element._key != "string")
    throw new Error("Expected element to have a _key property");
  if (editor.isInline(element)) {
    const path = ReactEditor.findPath(editor, element), [block] = Editor.node(editor, path, {
      depth: 1
    }), schemaType = schemaTypes.inlineObjects.find((_type) => _type.name === element._type);
    if (!schemaType)
      throw new Error("Could not find type for inline block element");
    if (Element$1.isElement(block)) {
      const elmPath = [{
        _key: block._key
      }, "children", {
        _key: element._key
      }];
      return /* @__PURE__ */ jsxs("span", { ...attributes, children: [
        children,
        /* @__PURE__ */ jsxs("span", { draggable: !readOnly, className: "pt-inline-object", "data-testid": "pt-inline-object", ref: inlineBlockObjectRef, style: inlineBlockStyle, contentEditable: !1, children: [
          renderChild && renderChild({
            annotations: EMPTY_ANNOTATIONS,
            // These inline objects currently doesn't support annotations. This is a limitation of the current PT spec/model.
            children: /* @__PURE__ */ jsx(DefaultInlineObject, { value }),
            editorElementRef: inlineBlockObjectRef,
            focused,
            path: elmPath,
            schemaType,
            selected,
            type: schemaType,
            value
          }),
          !renderChild && /* @__PURE__ */ jsx(DefaultInlineObject, { value })
        ] }, element._key)
      ] });
    }
    throw new Error("Block not found!");
  }
  if (element._type === schemaTypes.block.name) {
    className = "pt-block pt-text-block";
    const isListItem = "listItem" in element, style = "style" in element && element.style || "normal";
    className = `pt-block pt-text-block pt-text-block-style-${style}`;
    const blockStyleType = schemaTypes.styles.find((item) => item.value === style);
    renderStyle && blockStyleType && (renderedBlock = renderStyle({
      block: element,
      children,
      focused,
      selected,
      value: style,
      path: blockPath,
      schemaType: blockStyleType,
      editorElementRef: blockRef
    }));
    let level;
    if (isListItem && (typeof element.level == "number" && (level = element.level), className += ` pt-list-item pt-list-item-${element.listItem} pt-list-item-level-${level || 1}`), editor.isListBlock(value) && isListItem && element.listItem) {
      const listType = schemaTypes.lists.find((item_0) => item_0.value === element.listItem);
      renderListItem && listType && (renderedBlock = renderListItem({
        block: value,
        children: renderedBlock,
        focused,
        selected,
        value: element.listItem,
        path: blockPath,
        schemaType: listType,
        level: value.level || 1,
        editorElementRef: blockRef
      }));
    }
    const renderProps = Object.defineProperty({
      children: renderedBlock,
      editorElementRef: blockRef,
      focused,
      level,
      listItem: isListItem ? element.listItem : void 0,
      path: blockPath,
      selected,
      style,
      schemaType: schemaTypes.block,
      value
    }, "type", {
      enumerable: !1,
      get() {
        return console.warn("Property 'type' is deprecated, use 'schemaType' instead."), schemaTypes.block;
      }
    }), propsOrDefaultRendered = renderBlock ? renderBlock(renderProps) : children;
    return /* @__PURE__ */ jsxs("div", { ...attributes, className, spellCheck, ...droppable.droppableProps, children: [
      droppable.isDraggingOverTop ? /* @__PURE__ */ jsx(DropIndicator, {}) : null,
      /* @__PURE__ */ jsx("div", { ref: blockRef, children: propsOrDefaultRendered }),
      droppable.isDraggingOverBottom ? /* @__PURE__ */ jsx(DropIndicator, {}) : null
    ] }, element._key);
  }
  const schemaType_0 = schemaTypes.blockObjects.find((_type_0) => _type_0.name === element._type);
  if (!schemaType_0)
    throw new Error(`Could not find schema type for block element of _type ${element._type}`);
  className = "pt-block pt-object-block";
  const block_0 = fromSlateValue([element], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
  let renderedBlockFromProps;
  if (renderBlock) {
    const _props = Object.defineProperty({
      children: /* @__PURE__ */ jsx(DefaultBlockObject, { value }),
      editorElementRef: blockRef,
      focused,
      path: blockPath,
      schemaType: schemaType_0,
      selected,
      value: block_0
    }, "type", {
      enumerable: !1,
      get() {
        return console.warn("Property 'type' is deprecated, use 'schemaType' instead."), schemaType_0;
      }
    });
    renderedBlockFromProps = renderBlock(_props);
  }
  return /* @__PURE__ */ jsxs("div", { ...attributes, className, ...droppable.droppableProps, ...draggable.draggableProps, children: [
    droppable.isDraggingOverTop ? /* @__PURE__ */ jsx(DropIndicator, {}) : null,
    children,
    /* @__PURE__ */ jsx("div", { ref: blockRef, contentEditable: !1, children: renderedBlockFromProps || /* @__PURE__ */ jsx(DefaultBlockObject, { value }) }),
    droppable.isDraggingOverBottom ? /* @__PURE__ */ jsx(DropIndicator, {}) : null
  ] }, element._key);
};
Element.displayName = "Element";
const debug$2 = debugWithName("components:Leaf"), EMPTY_MARKS = [], Leaf = (props) => {
  const {
    editorActor,
    attributes,
    children,
    leaf,
    schemaTypes,
    renderChild,
    renderDecorator,
    renderAnnotation
  } = props, spanRef = useRef(null), portableTextEditor = usePortableTextEditor(), blockSelected = useSelected(), [focused, setFocused] = useState(!1), [selected, setSelected] = useState(!1), block = children.props.parent, path = useMemo(() => block ? [{
    _key: block?._key
  }, "children", {
    _key: leaf._key
  }] : [], [block, leaf._key]), decoratorValues = useMemo(() => schemaTypes.decorators.map((dec) => dec.value), [schemaTypes.decorators]), marks = useMemo(() => uniq((leaf.marks || EMPTY_MARKS).filter((mark) => decoratorValues.includes(mark))), [decoratorValues, leaf.marks]), annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS, annotations = useMemo(() => annotationMarks.map((mark_0) => !decoratorValues.includes(mark_0) && block?.markDefs?.find((def) => def._key === mark_0)).filter(Boolean), [annotationMarks, block, decoratorValues]), shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected;
  useEffect(() => {
    if (!shouldTrackSelectionAndFocus) {
      setFocused(!1);
      return;
    }
    const sel = PortableTextEditor.getSelection(portableTextEditor);
    sel && isEqual(sel.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && startTransition(() => {
      setFocused(!0);
    });
  }, [shouldTrackSelectionAndFocus, path, portableTextEditor]);
  const setSelectedFromRange = useCallback(() => {
    if (!shouldTrackSelectionAndFocus)
      return;
    debug$2("Setting selection and focus from range");
    const winSelection = window.getSelection();
    if (!winSelection) {
      setSelected(!1);
      return;
    }
    if (winSelection && winSelection.rangeCount > 0) {
      const range = winSelection.getRangeAt(0);
      spanRef.current && range.intersectsNode(spanRef.current) ? setSelected(!0) : setSelected(!1);
    } else
      setSelected(!1);
  }, [shouldTrackSelectionAndFocus]);
  useEffect(() => {
    if (!shouldTrackSelectionAndFocus)
      return;
    const onBlur = editorActor.on("blur", () => {
      setFocused(!1), setSelected(!1);
    }), onFocus = editorActor.on("focus", () => {
      const sel_0 = PortableTextEditor.getSelection(portableTextEditor);
      sel_0 && isEqual(sel_0.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && setFocused(!0), setSelectedFromRange();
    }), onSelection = editorActor.on("selection", (event) => {
      event.selection && isEqual(event.selection.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) ? setFocused(!0) : setFocused(!1), setSelectedFromRange();
    });
    return () => {
      onBlur.unsubscribe(), onFocus.unsubscribe(), onSelection.unsubscribe();
    };
  }, [editorActor, path, portableTextEditor, setSelectedFromRange, shouldTrackSelectionAndFocus]), useEffect(() => setSelectedFromRange(), [setSelectedFromRange]);
  const content = useMemo(() => {
    let returnedChildren = children;
    if (Text.isText(leaf) && leaf._type === schemaTypes.span.name && (marks.forEach((mark_1) => {
      const schemaType = schemaTypes.decorators.find((dec_0) => dec_0.value === mark_1);
      if (schemaType && renderDecorator) {
        const _props = Object.defineProperty({
          children: returnedChildren,
          editorElementRef: spanRef,
          focused,
          path,
          selected,
          schemaType,
          value: mark_1
        }, "type", {
          enumerable: !1,
          get() {
            return console.warn("Property 'type' is deprecated, use 'schemaType' instead."), schemaType;
          }
        });
        returnedChildren = renderDecorator(_props);
      }
    }), block && annotations.length > 0 && annotations.forEach((annotation) => {
      const schemaType_0 = schemaTypes.annotations.find((t) => t.name === annotation._type);
      if (schemaType_0)
        if (renderAnnotation) {
          const _props_0 = Object.defineProperty({
            block,
            children: returnedChildren,
            editorElementRef: spanRef,
            focused,
            path,
            selected,
            schemaType: schemaType_0,
            value: annotation
          }, "type", {
            enumerable: !1,
            get() {
              return console.warn("Property 'type' is deprecated, use 'schemaType' instead."), schemaType_0;
            }
          });
          returnedChildren = /* @__PURE__ */ jsx("span", { ref: spanRef, children: renderAnnotation(_props_0) });
        } else
          returnedChildren = /* @__PURE__ */ jsx("span", { ref: spanRef, children: returnedChildren });
    }), block && renderChild)) {
      const child = block.children.find((_child) => _child._key === leaf._key);
      if (child) {
        const _props_1 = Object.defineProperty({
          annotations,
          children: /* @__PURE__ */ jsx(Fragment, { children: returnedChildren }),
          editorElementRef: spanRef,
          focused,
          path,
          schemaType: schemaTypes.span,
          selected,
          value: child
        }, "type", {
          enumerable: !1,
          get() {
            return console.warn("Property 'type' is deprecated, use 'schemaType' instead."), schemaTypes.span;
          }
        });
        returnedChildren = renderChild(_props_1);
      }
    }
    return returnedChildren;
  }, [annotations, block, children, focused, leaf, marks, path, renderAnnotation, renderChild, renderDecorator, schemaTypes.annotations, schemaTypes.decorators, schemaTypes.span, selected]);
  return useMemo(() => /* @__PURE__ */ jsx("span", { ...attributes, ref: spanRef, children: content }, leaf._key), [leaf, attributes, content]);
};
Leaf.displayName = "Leaf";
const debug$1 = debugWithName("plugin:withHotKeys");
function createWithHotkeys(editorActor, portableTextEditor, hotkeysFromOptions) {
  const reservedHotkeys = ["enter", "tab", "shift", "delete", "end"], activeHotkeys = hotkeysFromOptions ?? {};
  return function(editor) {
    return editor.pteWithHotKeys = (event) => {
      Object.keys(activeHotkeys).forEach((cat) => {
        if (cat === "marks")
          for (const hotkey in activeHotkeys[cat]) {
            if (reservedHotkeys.includes(hotkey))
              throw new Error(`The hotkey ${hotkey} is reserved!`);
            if (isHotkey(hotkey, event.nativeEvent)) {
              event.preventDefault();
              const possibleMark = activeHotkeys[cat];
              if (possibleMark) {
                const mark = possibleMark[hotkey];
                debug$1(`HotKey ${hotkey} to toggle ${mark}`), editorActor.send({
                  type: "behavior event",
                  behaviorEvent: {
                    type: "decorator.toggle",
                    decorator: mark
                  },
                  editor
                });
              }
            }
          }
        if (cat === "custom")
          for (const hotkey in activeHotkeys[cat]) {
            if (reservedHotkeys.includes(hotkey))
              throw new Error(`The hotkey ${hotkey} is reserved!`);
            if (isHotkey(hotkey, event.nativeEvent)) {
              const possibleCommand = activeHotkeys[cat];
              if (possibleCommand) {
                const command = possibleCommand[hotkey];
                command(event, portableTextEditor);
              }
            }
          }
      });
    }, editor;
  };
}
function withSyncRangeDecorations({
  editorActor,
  slateEditor,
  syncRangeDecorations
}) {
  const originalApply = slateEditor.apply;
  return slateEditor.apply = (op) => {
    originalApply(op), !editorActor.getSnapshot().matches({
      "edit mode": "read only"
    }) && op.type !== "set_selection" && syncRangeDecorations(op);
  }, () => {
    slateEditor.apply = originalApply;
  };
}
const debug = debugWithName("component:Editable"), PLACEHOLDER_STYLE = {
  position: "absolute",
  userSelect: "none",
  pointerEvents: "none",
  left: 0,
  right: 0
}, PortableTextEditable = forwardRef(function(props, forwardedRef) {
  const {
    hotkeys,
    onBlur,
    onFocus,
    onBeforeInput,
    onPaste,
    onCopy,
    onClick,
    rangeDecorations,
    renderAnnotation,
    renderBlock,
    renderChild,
    renderDecorator,
    renderListItem,
    renderPlaceholder,
    renderStyle,
    selection: propsSelection,
    scrollSelectionIntoView,
    spellCheck,
    ...restProps
  } = props, portableTextEditor = usePortableTextEditor(), ref = useRef(null), [editableElement, setEditableElement] = useState(null), [hasInvalidValue, setHasInvalidValue] = useState(!1), [rangeDecorationState, setRangeDecorationsState] = useState([]);
  useImperativeHandle(forwardedRef, () => ref.current);
  const rangeDecorationsRef = useRef(rangeDecorations), editorActor = useContext(EditorActorContext), readOnly = useSelector(editorActor, (s) => s.matches({
    "edit mode": "read only"
  })), schemaTypes = useSelector(editorActor, (s_0) => s_0.context.schema), slateEditor = useSlate(), blockTypeName = schemaTypes.block.name;
  useMemo(() => {
    if (readOnly)
      return debug("Editable is in read only mode"), slateEditor;
    const withHotKeys = createWithHotkeys(editorActor, portableTextEditor, hotkeys);
    return debug("Editable is in edit mode"), withHotKeys(slateEditor);
  }, [editorActor, hotkeys, portableTextEditor, readOnly, slateEditor]);
  const renderElement = useCallback((eProps) => /* @__PURE__ */ jsx(Element, { ...eProps, readOnly, renderBlock, renderChild, renderListItem, renderStyle, schemaTypes, spellCheck }), [schemaTypes, spellCheck, readOnly, renderBlock, renderChild, renderListItem, renderStyle]), renderLeaf = useCallback((lProps) => {
    if (lProps.leaf._type === "span") {
      let rendered = /* @__PURE__ */ jsx(Leaf, { ...lProps, editorActor, schemaTypes, renderAnnotation, renderChild, renderDecorator, readOnly });
      if (renderPlaceholder && lProps.leaf.placeholder && lProps.text.text === "")
        return /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx("span", { style: PLACEHOLDER_STYLE, contentEditable: !1, children: renderPlaceholder() }),
          rendered
        ] });
      const decoration = lProps.leaf.rangeDecoration;
      return decoration && (rendered = decoration.component({
        children: rendered
      })), rendered;
    }
    return lProps.children;
  }, [editorActor, readOnly, renderAnnotation, renderChild, renderDecorator, renderPlaceholder, schemaTypes]), restoreSelectionFromProps = useCallback(() => {
    if (propsSelection) {
      debug(`Selection from props ${JSON.stringify(propsSelection)}`);
      const normalizedSelection = normalizeSelection(propsSelection, fromSlateValue(slateEditor.children, blockTypeName));
      if (normalizedSelection !== null) {
        debug(`Normalized selection from props ${JSON.stringify(normalizedSelection)}`);
        const slateRange = toSlateRange(normalizedSelection, slateEditor);
        slateRange && (Transforms.select(slateEditor, slateRange), slateEditor.operations.some((o) => o.type === "set_selection") || editorActor.send({
          type: "notify.selection",
          selection: normalizedSelection
        }), slateEditor.onChange());
      }
    }
  }, [blockTypeName, editorActor, propsSelection, slateEditor]), syncRangeDecorations = useCallback((operation) => {
    if (rangeDecorations && rangeDecorations.length > 0) {
      const newSlateRanges = [];
      if (rangeDecorations.forEach((rangeDecorationItem) => {
        const slateRange_0 = toSlateRange(rangeDecorationItem.selection, slateEditor);
        if (!Range.isRange(slateRange_0)) {
          rangeDecorationItem.onMoved && rangeDecorationItem.onMoved({
            newSelection: null,
            rangeDecoration: rangeDecorationItem,
            origin: "local"
          });
          return;
        }
        let newRange;
        if (operation && (newRange = moveRangeByOperation(slateRange_0, operation), newRange && newRange !== slateRange_0 || newRange === null && slateRange_0)) {
          const value = PortableTextEditor.getValue(portableTextEditor), newRangeSelection = toPortableTextRange(value, newRange, schemaTypes);
          rangeDecorationItem.onMoved && rangeDecorationItem.onMoved({
            newSelection: newRangeSelection,
            rangeDecoration: rangeDecorationItem,
            origin: "local"
          });
        }
        newRange !== null && newSlateRanges.push({
          ...newRange || slateRange_0,
          rangeDecoration: rangeDecorationItem
        });
      }), newSlateRanges.length > 0) {
        setRangeDecorationsState(newSlateRanges);
        return;
      }
    }
    setRangeDecorationsState((rangeDecorationState_0) => rangeDecorationState_0.length > 0 ? [] : rangeDecorationState_0);
  }, [portableTextEditor, rangeDecorations, schemaTypes, slateEditor]);
  useEffect(() => {
    const onReady = editorActor.on("ready", () => {
      syncRangeDecorations(), restoreSelectionFromProps();
    }), onInvalidValue = editorActor.on("invalid value", () => {
      setHasInvalidValue(!0);
    }), onValueChanged = editorActor.on("value changed", () => {
      setHasInvalidValue(!1);
    });
    return () => {
      onReady.unsubscribe(), onInvalidValue.unsubscribe(), onValueChanged.unsubscribe();
    };
  }, [editorActor, restoreSelectionFromProps, syncRangeDecorations]), useEffect(() => {
    propsSelection && !hasInvalidValue && restoreSelectionFromProps();
  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps]);
  const [syncedRangeDecorations, setSyncedRangeDecorations] = useState(!1);
  useEffect(() => {
    syncedRangeDecorations || (setSyncedRangeDecorations(!0), syncRangeDecorations());
  }, [syncRangeDecorations, syncedRangeDecorations]), useEffect(() => {
    isEqual(rangeDecorations, rangeDecorationsRef.current) || syncRangeDecorations(), rangeDecorationsRef.current = rangeDecorations;
  }, [rangeDecorations, syncRangeDecorations]), useEffect(() => {
    const teardown = withSyncRangeDecorations({
      editorActor,
      slateEditor,
      syncRangeDecorations
    });
    return () => teardown();
  }, [editorActor, slateEditor, syncRangeDecorations]);
  const handleCopy = useCallback((event) => {
    onCopy ? onCopy(event) !== void 0 && event.preventDefault() : event.nativeEvent.clipboardData && editorActor.send({
      type: "behavior event",
      behaviorEvent: {
        type: "copy",
        data: event.nativeEvent.clipboardData
      },
      editor: slateEditor,
      nativeEvent: event
    });
  }, [onCopy, editorActor, slateEditor]), handlePaste = useCallback((event_0) => {
    const value_0 = PortableTextEditor.getValue(portableTextEditor), path = toPortableTextRange(value_0, slateEditor.selection, schemaTypes)?.focus.path || [], onPasteResult = onPaste?.({
      event: event_0,
      value: value_0,
      path,
      schemaTypes
    });
    onPasteResult || !slateEditor.selection ? (event_0.preventDefault(), editorActor.send({
      type: "notify.loading"
    }), Promise.resolve(onPasteResult).then((result_0) => {
      debug("Custom paste function from client resolved", result_0), !result_0 || !result_0.insert ? (debug("No result from custom paste handler, pasting normally"), slateEditor.insertData(event_0.clipboardData)) : result_0.insert ? slateEditor.insertFragment(toSlateValue(result_0.insert, {
        schemaTypes
      })) : console.warn("Your onPaste function returned something unexpected:", result_0);
    }).catch((error) => (console.error(error), error)).finally(() => {
      editorActor.send({
        type: "notify.done loading"
      });
    })) : event_0.nativeEvent.clipboardData && editorActor.send({
      type: "behavior event",
      behaviorEvent: {
        type: "paste",
        data: event_0.nativeEvent.clipboardData
      },
      editor: slateEditor,
      nativeEvent: event_0
    }), debug("No result from custom paste handler, pasting normally");
  }, [editorActor, onPaste, portableTextEditor, schemaTypes, slateEditor]), handleOnFocus = useCallback((event_1) => {
    if (onFocus && onFocus(event_1), !event_1.isDefaultPrevented()) {
      const selection = PortableTextEditor.getSelection(portableTextEditor);
      selection === null && (Transforms.select(slateEditor, Editor.start(slateEditor, [])), slateEditor.onChange()), editorActor.send({
        type: "notify.focused",
        event: event_1
      });
      const newSelection = PortableTextEditor.getSelection(portableTextEditor);
      selection === newSelection && editorActor.send({
        type: "notify.selection",
        selection
      });
    }
  }, [editorActor, onFocus, portableTextEditor, slateEditor]), handleClick = useCallback((event_2) => {
    onClick && onClick(event_2);
    const focusBlockPath = slateEditor.selection ? slateEditor.selection.focus.path.slice(0, 1) : void 0, focusBlock = focusBlockPath ? Node.descendant(slateEditor, focusBlockPath) : void 0, [_, lastNodePath] = Node.last(slateEditor, []), lastBlockPath = lastNodePath.slice(0, 1), lastNodeFocused = focusBlockPath ? Path.equals(lastBlockPath, focusBlockPath) : !1, lastBlockIsVoid = focusBlock ? !slateEditor.isTextBlock(focusBlock) : !1;
    slateEditor.selection && Range.isCollapsed(slateEditor.selection) && lastNodeFocused && lastBlockIsVoid && (Transforms.insertNodes(slateEditor, slateEditor.pteCreateTextBlock({
      decorators: []
    })), slateEditor.onChange());
  }, [onClick, slateEditor]), handleOnBlur = useCallback((event_3) => {
    onBlur && onBlur(event_3), event_3.isPropagationStopped() || editorActor.send({
      type: "notify.blurred",
      event: event_3
    });
  }, [editorActor, onBlur]), handleOnBeforeInput = useCallback((event_4) => {
    onBeforeInput && onBeforeInput(event_4);
  }, [onBeforeInput]), validateSelection = useCallback(() => {
    if (!slateEditor.selection)
      return;
    const root = ReactEditor.findDocumentOrShadowRoot(slateEditor), {
      activeElement
    } = root;
    if (ref.current !== activeElement)
      return;
    const domSelection = ReactEditor.getWindow(slateEditor).getSelection();
    if (!domSelection || domSelection.rangeCount === 0)
      return;
    const existingDOMRange = domSelection.getRangeAt(0);
    try {
      const newDOMRange = ReactEditor.toDOMRange(slateEditor, slateEditor.selection);
      (newDOMRange.startOffset !== existingDOMRange.startOffset || newDOMRange.endOffset !== existingDOMRange.endOffset) && (debug("DOM range out of sync, validating selection"), domSelection?.removeAllRanges(), domSelection.addRange(newDOMRange));
    } catch {
      debug("Could not resolve selection, selecting top document"), Transforms.deselect(slateEditor), slateEditor.children.length > 0 && Transforms.select(slateEditor, [0, 0]), slateEditor.onChange();
    }
  }, [ref, slateEditor]);
  useEffect(() => {
    if (editableElement) {
      const mutationObserver = new MutationObserver(validateSelection);
      return mutationObserver.observe(editableElement, {
        attributeOldValue: !1,
        attributes: !1,
        characterData: !1,
        childList: !0,
        subtree: !0
      }), () => {
        mutationObserver.disconnect();
      };
    }
  }, [validateSelection, editableElement]);
  const handleKeyDown = useCallback((event_5) => {
    props.onKeyDown && props.onKeyDown(event_5), event_5.isDefaultPrevented() || slateEditor.pteWithHotKeys(event_5), event_5.isDefaultPrevented() || editorActor.send({
      type: "behavior event",
      behaviorEvent: {
        type: "key.down",
        keyboardEvent: {
          key: event_5.key,
          code: event_5.code,
          altKey: event_5.altKey,
          ctrlKey: event_5.ctrlKey,
          metaKey: event_5.metaKey,
          shiftKey: event_5.shiftKey
        }
      },
      editor: slateEditor,
      nativeEvent: event_5
    });
  }, [props, editorActor, slateEditor]), handleKeyUp = useCallback((event_6) => {
    props.onKeyUp && props.onKeyUp(event_6), event_6.isDefaultPrevented() || editorActor.send({
      type: "behavior event",
      behaviorEvent: {
        type: "key.up",
        keyboardEvent: {
          key: event_6.key,
          code: event_6.code,
          altKey: event_6.altKey,
          ctrlKey: event_6.ctrlKey,
          metaKey: event_6.metaKey,
          shiftKey: event_6.shiftKey
        }
      },
      editor: slateEditor,
      nativeEvent: event_6
    });
  }, [props, editorActor, slateEditor]), scrollSelectionIntoViewToSlate = useMemo(() => {
    if (scrollSelectionIntoView !== void 0)
      return scrollSelectionIntoView === null ? noop : (_editor, domRange) => {
        scrollSelectionIntoView(portableTextEditor, domRange);
      };
  }, [portableTextEditor, scrollSelectionIntoView]), decorate = useCallback(([, path_0]) => {
    if (isEqualToEmptyEditor(slateEditor.children, schemaTypes))
      return [{
        anchor: {
          path: [0, 0],
          offset: 0
        },
        focus: {
          path: [0, 0],
          offset: 0
        },
        placeholder: !0
      }];
    if (path_0.length === 0)
      return [];
    const result_1 = rangeDecorationState.filter((item) => Range.isCollapsed(item) ? path_0.length !== 2 ? !1 : Path.equals(item.focus.path, path_0) && Path.equals(item.anchor.path, path_0) : Range.intersection(item, {
      anchor: {
        path: path_0,
        offset: 0
      },
      focus: {
        path: path_0,
        offset: 0
      }
    }) || Range.includes(item, path_0));
    return result_1.length > 0 ? result_1 : [];
  }, [slateEditor, schemaTypes, rangeDecorationState]);
  return useEffect(() => {
    ref.current = ReactEditor.toDOMNode(slateEditor, slateEditor), setEditableElement(ref.current);
  }, [slateEditor, ref]), useEffect(() => {
    const window_0 = ReactEditor.getWindow(slateEditor), onDragEnd = () => {
      editorActor.send({
        type: "dragend"
      });
    }, onDrop = () => {
      editorActor.send({
        type: "drop"
      });
    };
    return window_0.document.addEventListener("dragend", onDragEnd), window_0.document.addEventListener("drop", onDrop), () => {
      window_0.document.removeEventListener("dragend", onDragEnd), window_0.document.removeEventListener("drop", onDrop);
    };
  }, [slateEditor, editorActor]), portableTextEditor ? hasInvalidValue ? null : /* @__PURE__ */ jsx(
    Editable,
    {
      ...restProps,
      autoFocus: !1,
      className: restProps.className || "pt-editable",
      decorate,
      onBlur: handleOnBlur,
      onCopy: handleCopy,
      onClick: handleClick,
      onDOMBeforeInput: handleOnBeforeInput,
      onDragStart: (event_7) => {
        props.onDragStart?.(event_7), !event_7.isDefaultPrevented() && !event_7.isPropagationStopped() && editorActor.send({
          type: "dragstart"
        });
      },
      onFocus: handleOnFocus,
      onKeyDown: handleKeyDown,
      onKeyUp: handleKeyUp,
      onPaste: handlePaste,
      readOnly,
      renderPlaceholder: void 0,
      renderElement,
      renderLeaf,
      scrollSelectionIntoView: scrollSelectionIntoViewToSlate
    }
  ) : null;
});
PortableTextEditable.displayName = "ForwardRef(PortableTextEditable)";
function EditorEventListener(props) {
  const $ = c(5), editor = useEditor(), on = useEffectEvent(props.on);
  let t0;
  $[0] !== editor || $[1] !== on ? (t0 = () => {
    const subscription = editor.on("*", on);
    return () => {
      subscription.unsubscribe();
    };
  }, $[0] = editor, $[1] = on, $[2] = t0) : t0 = $[2];
  let t1;
  return $[3] !== editor ? (t1 = [editor], $[3] = editor, $[4] = t1) : t1 = $[4], useEffect(t0, t1), null;
}
export {
  EditorEventListener,
  EditorProvider,
  PortableTextEditable,
  PortableTextEditor,
  defineSchema,
  defaultKeyGenerator as keyGenerator,
  useEditor,
  useEditorSelector,
  usePortableTextEditor,
  usePortableTextEditorSelection
};
//# sourceMappingURL=index.js.map
