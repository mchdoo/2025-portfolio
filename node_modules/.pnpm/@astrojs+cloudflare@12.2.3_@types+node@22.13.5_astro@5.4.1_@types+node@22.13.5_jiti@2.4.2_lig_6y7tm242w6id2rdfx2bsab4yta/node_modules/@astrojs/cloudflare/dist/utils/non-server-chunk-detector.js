class NonServerChunkDetector {
  nonServerChunks;
  getPlugin() {
    return {
      name: "non-server-chunk-detector",
      generateBundle: (_, bundle) => {
        if (!bundle["index.js"]) return;
        this.processBundle(bundle);
      }
    };
  }
  processBundle(bundle) {
    const chunkNamesToFiles = /* @__PURE__ */ new Map();
    const entryChunks = [];
    const chunkToDependencies = /* @__PURE__ */ new Map();
    for (const chunk of Object.values(bundle)) {
      if (chunk.type !== "chunk") continue;
      chunkNamesToFiles.set(chunk.name, chunk.fileName);
      chunkToDependencies.set(chunk.fileName, [...chunk.imports, ...chunk.dynamicImports]);
      if (chunk.isEntry) {
        entryChunks.push(chunk.fileName);
      }
    }
    const chunkDecisions = /* @__PURE__ */ new Map();
    for (const entry of entryChunks) {
      chunkDecisions.set(entry, true);
    }
    for (const chunk of ["prerender", "prerender@_@astro"]) {
      const fileName = chunkNamesToFiles.get(chunk);
      if (fileName) {
        chunkDecisions.set(fileName, false);
      }
    }
    const chunksToWalk = [...entryChunks];
    for (let chunk = chunksToWalk.pop(); chunk; chunk = chunksToWalk.pop()) {
      for (const dep of chunkToDependencies.get(chunk) ?? []) {
        if (chunkDecisions.has(dep)) continue;
        chunkDecisions.set(dep, true);
        chunksToWalk.push(dep);
      }
    }
    this.nonServerChunks = Array.from(chunkToDependencies.keys()).filter(
      (chunk) => !chunkDecisions.get(chunk)
    );
  }
  getNonServerChunks() {
    return this.nonServerChunks ?? [];
  }
}
export {
  NonServerChunkDetector
};
