{"version":3,"file":"helpers.js","sources":["../../src/_internal/cli/actions/deploy/helpers.ts"],"sourcesContent":["import fs from 'node:fs/promises'\nimport path from 'node:path'\nimport {PassThrough} from 'node:stream'\nimport {type Gzip} from 'node:zlib'\n\nimport {type CliCommandContext, type CliOutputter} from '@sanity/cli'\nimport {type SanityClient} from '@sanity/client'\nimport FormData from 'form-data'\nimport {customAlphabet} from 'nanoid'\nimport readPkgUp from 'read-pkg-up'\n\nimport {debug as debugIt} from '../../debug'\n\nexport const debug = debugIt.extend('deploy')\n\n// TODO: replace with `Promise.withResolvers()` once it lands in node\nfunction promiseWithResolvers<T>() {\n  let resolve!: (t: T) => void\n  let reject!: (err: unknown) => void\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n  return {promise, resolve, reject}\n}\n\nexport interface ActiveDeployment {\n  deployedAt: string\n  deployedBy: string\n  isActiveDeployment: boolean\n  isAutoUpdating: boolean | null\n  size: string | null\n  createdAt: string\n  updatedAt: string\n  version: string\n}\n\nexport interface UserApplication {\n  id: string\n  projectId: string | null\n  organizationId: string | null\n  title: string | null\n  appHost: string\n  urlType: 'internal' | 'external'\n  createdAt: string\n  updatedAt: string\n  type: 'studio' | 'coreApp'\n  activeDeployment?: ActiveDeployment | null\n}\n\nexport interface GetUserApplicationsOptions {\n  client: SanityClient\n  organizationId?: string\n}\n\nexport interface GetUserApplicationOptions extends GetUserApplicationsOptions {\n  appHost?: string\n  appId?: string\n}\nexport async function getUserApplication({\n  client,\n  appHost,\n  appId,\n}: GetUserApplicationOptions): Promise<UserApplication | null> {\n  let query\n  let uri = '/user-applications'\n  if (appId) {\n    uri = `/user-applications/${appId}`\n    query = {appType: 'coreApp'}\n  } else if (appHost) {\n    query = {appHost}\n  } else {\n    query = {default: 'true'}\n  }\n  try {\n    return await client.request({uri, query})\n  } catch (e) {\n    if (e?.statusCode === 404) {\n      return null\n    }\n\n    debug('Error getting user application', e)\n    throw e\n  }\n}\nexport async function getUserApplications({\n  client,\n  organizationId,\n}: GetUserApplicationsOptions): Promise<UserApplication[] | null> {\n  const query: Record<string, string> = organizationId\n    ? {organizationId: organizationId, appType: 'coreApp'}\n    : {appType: 'studio'}\n  try {\n    return await client.request({\n      uri: '/user-applications',\n      query,\n    })\n  } catch (e) {\n    if (e?.statusCode === 404) {\n      return null\n    }\n\n    debug('Error getting user applications', e)\n    throw e\n  }\n}\n\nfunction createUserApplication(\n  client: SanityClient,\n  body: Pick<UserApplication, 'appHost' | 'urlType' | 'type'> & {\n    title?: string\n  },\n  organizationId?: string,\n): Promise<UserApplication> {\n  const query: Record<string, string> = organizationId\n    ? {organizationId: organizationId, appType: 'coreApp'}\n    : {appType: 'studio'}\n  return client.request({uri: '/user-applications', method: 'POST', body, query})\n}\n\ninterface SelectApplicationOptions {\n  client: SanityClient\n  prompt: GetOrCreateUserApplicationOptions['context']['prompt']\n  message: string\n  createNewLabel: string\n  organizationId?: string\n}\n\n/**\n * Shared utility for selecting an existing application or opting to create a new one\n * @internal\n */\nasync function selectExistingApplication({\n  client,\n  prompt,\n  message,\n  createNewLabel,\n  organizationId,\n}: SelectApplicationOptions): Promise<UserApplication | null> {\n  const userApplications = await getUserApplications({client, organizationId})\n\n  if (!userApplications?.length) {\n    return null\n  }\n\n  const choices = userApplications.map((app) => ({\n    value: app.appHost,\n    name: app.title ?? app.appHost,\n  }))\n\n  const selected = await prompt.single({\n    message,\n    type: 'list',\n    choices: [{value: 'new', name: createNewLabel}, new prompt.Separator(), ...choices],\n  })\n\n  if (selected === 'new') {\n    return null\n  }\n\n  return userApplications.find((app) => app.appHost === selected)!\n}\n\nexport interface GetOrCreateUserApplicationOptions {\n  client: SanityClient\n  context: Pick<CliCommandContext, 'output' | 'prompt' | 'cliConfig'>\n  spinner: ReturnType<CliOutputter['spinner']>\n}\n\n/**\n * These functions handle the logic for managing user applications when\n * studioHost is not provided in the CLI config.\n *\n * @internal\n *\n *    +-------------------------------+\n *    |   Fetch Existing user-app?   |\n *    +---------+--------------------+\n *              |\n *        +-----+-----+\n *        |           |\n *        v           v\n *   +---------+  +-------------------------+\n *   | Return  |  | Fetch all user apps     |\n *   | user-app|  +-------------------------+\n *   +---------+            |\n *                          v\n *           +---------------------------+\n *           |  User apps found?         |\n *           +-----------+---------------+\n *                       |\n *                +------v------+\n *                |             |\n *                v             v\n *   +--------------------+  +------------------------+\n *   | Show list and      |  | Prompt for hostname    |\n *   | prompt selection   |  | and create new app     |\n *   +--------------------+  +------------------------+\n */\nexport async function getOrCreateStudio({\n  client,\n  spinner,\n  context,\n}: GetOrCreateUserApplicationOptions): Promise<UserApplication> {\n  const {output, prompt} = context\n  // if there is already an existing user-app, then just return it\n  const existingUserApplication = await getUserApplication({client})\n\n  // Complete the spinner so prompt can properly work\n  spinner.succeed()\n\n  if (existingUserApplication) {\n    return existingUserApplication\n  }\n\n  const selectedApp = await selectExistingApplication({\n    client,\n    prompt,\n    message: 'Select existing studio hostname',\n    createNewLabel: 'Create new studio hostname',\n  })\n\n  if (selectedApp) {\n    return selectedApp\n  }\n\n  // otherwise, prompt the user for a hostname\n  output.print('Your project has not been assigned a studio hostname.')\n  output.print('To deploy your Sanity Studio to our hosted sanity.studio service,')\n  output.print('you will need one. Please enter the part you want to use.')\n\n  const {promise, resolve} = promiseWithResolvers<UserApplication>()\n\n  await prompt.single({\n    type: 'input',\n    filter: (inp: string) => inp.replace(/\\.sanity\\.studio$/i, ''),\n    message: 'Studio hostname (<value>.sanity.studio):',\n    // if a string is returned here, it is relayed to the user and prompt allows\n    // the user to try again until this function returns true\n    validate: async (appHost: string) => {\n      try {\n        const response = await createUserApplication(client, {\n          appHost,\n          urlType: 'internal',\n          type: 'studio',\n        })\n        resolve(response)\n        return true\n      } catch (e) {\n        // if the name is taken, it should return a 409 so we relay to the user\n        if ([402, 409].includes(e?.statusCode)) {\n          return e?.response?.body?.message || 'Bad request' // just in case\n        }\n\n        debug('Error creating user application', e)\n        // otherwise, it's a fatal error\n        throw e\n      }\n    },\n  })\n\n  return await promise\n}\n\n/**\n * Creates a core application with an auto-generated hostname\n *\n * @internal\n */\nexport async function getOrCreateCoreApplication({\n  client,\n  context,\n  spinner,\n}: GetOrCreateUserApplicationOptions): Promise<UserApplication> {\n  const {prompt, cliConfig} = context\n  const organizationId =\n    cliConfig &&\n    '__experimental_coreAppConfiguration' in cliConfig &&\n    cliConfig.__experimental_coreAppConfiguration?.organizationId\n\n  // Complete the spinner so prompt can properly work\n  spinner.succeed()\n\n  const selectedApp = await selectExistingApplication({\n    client,\n    prompt,\n    message: 'Select an existing deployed application',\n    createNewLabel: 'Create new deployed application',\n    organizationId: organizationId || undefined,\n  })\n\n  if (selectedApp) {\n    return selectedApp\n  }\n\n  // First get the title from the user\n  const title = await prompt.single({\n    type: 'input',\n    message: 'Enter a title for your application:',\n    validate: (input: string) => input.length > 0 || 'Title is required',\n  })\n\n  const {promise, resolve, reject} = promiseWithResolvers<UserApplication>()\n\n  // Try to create the application, retrying with new hostnames if needed\n  const tryCreateApp = async () => {\n    // appHosts have some restrictions (no uppercase, must start with a letter)\n    const generateId = () => {\n      const letters = 'abcdefghijklmnopqrstuvwxyz'\n      const firstChar = customAlphabet(letters, 1)()\n      const rest = customAlphabet('abcdefghijklmnopqrstuvwxyz0123456789', 11)()\n      return `${firstChar}${rest}`\n    }\n\n    // we will likely prepend this with an org ID or other parameter in the future\n    const appHost = generateId()\n\n    try {\n      const response = await createUserApplication(\n        client,\n        {\n          appHost,\n          urlType: 'internal',\n          title,\n          type: 'coreApp',\n        },\n        organizationId || undefined,\n      )\n      resolve(response)\n      return true\n    } catch (e) {\n      // if the name is taken, generate a new one and try again\n      if ([402, 409].includes(e?.statusCode)) {\n        debug('App host taken, retrying with new host')\n        return tryCreateApp()\n      }\n\n      debug('Error creating core application', e)\n      reject(e)\n      // otherwise, it's a fatal error\n      throw e\n    }\n  }\n\n  spinner.start('Creating application')\n\n  await tryCreateApp()\n  const response = await promise\n\n  spinner.succeed()\n  return response\n}\n\nexport interface BaseConfigOptions {\n  client: SanityClient\n  context: Pick<CliCommandContext, 'output' | 'prompt' | 'cliConfig'>\n  spinner: ReturnType<CliOutputter['spinner']>\n}\n\ninterface StudioConfigOptions extends BaseConfigOptions {\n  appHost: string\n}\n\ninterface CoreAppConfigOptions extends BaseConfigOptions {\n  appId?: string\n}\n\nasync function getOrCreateStudioFromConfig({\n  client,\n  context,\n  spinner,\n  appHost,\n}: StudioConfigOptions): Promise<UserApplication> {\n  const {output} = context\n  // if there is already an existing user-app, then just return it\n  const existingUserApplication = await getUserApplication({client, appHost})\n\n  // Complete the spinner so prompt can properly work\n  spinner.succeed()\n\n  if (existingUserApplication) {\n    return existingUserApplication\n  }\n\n  output.print('Your project has not been assigned a studio hostname.')\n  output.print(`Creating https://${appHost}.sanity.studio`)\n  output.print('')\n  spinner.start('Creating studio hostname')\n\n  try {\n    const response = await createUserApplication(client, {\n      appHost,\n      urlType: 'internal',\n      type: 'studio',\n    })\n    spinner.succeed()\n    return response\n  } catch (e) {\n    spinner.fail()\n    // if the name is taken, it should return a 409 so we relay to the user\n    if ([402, 409].includes(e?.statusCode)) {\n      throw new Error(e?.response?.body?.message || 'Bad request') // just in case\n    }\n    debug('Error creating user application from config', e)\n    // otherwise, it's a fatal error\n    throw e\n  }\n}\n\nasync function getOrCreateCoreAppFromConfig({\n  client,\n  context,\n  spinner,\n  appId,\n}: CoreAppConfigOptions): Promise<UserApplication> {\n  const {output, cliConfig} = context\n  const organizationId =\n    cliConfig &&\n    '__experimental_coreAppConfiguration' in cliConfig &&\n    cliConfig.__experimental_coreAppConfiguration?.organizationId\n  if (appId) {\n    const existingUserApplication = await getUserApplication({\n      client,\n      appId,\n      organizationId: organizationId || undefined,\n    })\n    spinner.succeed()\n\n    if (existingUserApplication) {\n      return existingUserApplication\n    }\n  }\n\n  // core apps cannot arbitrarily create ids or hosts, so send them to create option\n  output.print('The appId provided in your configuration is not recognized.')\n  output.print('Checking existing applications...')\n  return getOrCreateCoreApplication({client, context, spinner})\n}\n\n/**\n * This function handles the logic for managing user applications when\n * studioHost or appId is provided in the CLI config.\n *\n * @internal\n */\nexport async function getOrCreateUserApplicationFromConfig(\n  options: BaseConfigOptions & {\n    appHost?: string\n    appId?: string\n  },\n): Promise<UserApplication> {\n  const {context} = options\n  const isCoreApp = context.cliConfig && '__experimental_coreAppConfiguration' in context.cliConfig\n\n  if (isCoreApp) {\n    return getOrCreateCoreAppFromConfig(options)\n  }\n\n  if (!options.appHost) {\n    throw new Error('Studio host was detected, but is invalid')\n  }\n\n  return getOrCreateStudioFromConfig({...options, appHost: options.appHost})\n}\n\nexport interface CreateDeploymentOptions {\n  client: SanityClient\n  applicationId: string\n  version: string\n  isAutoUpdating: boolean\n  tarball: Gzip\n  isCoreApp?: boolean\n}\n\nexport async function createDeployment({\n  client,\n  tarball,\n  applicationId,\n  isAutoUpdating,\n  version,\n  isCoreApp,\n}: CreateDeploymentOptions): Promise<{location: string}> {\n  const formData = new FormData()\n  formData.append('isAutoUpdating', isAutoUpdating.toString())\n  formData.append('version', version)\n  formData.append('tarball', tarball, {contentType: 'application/gzip', filename: 'app.tar.gz'})\n\n  return client.request({\n    uri: `/user-applications/${applicationId}/deployments`,\n    method: 'POST',\n    headers: formData.getHeaders(),\n    body: formData.pipe(new PassThrough()),\n    query: isCoreApp ? {appType: 'coreApp'} : {appType: 'studio'},\n  })\n}\n\nexport interface DeleteUserApplicationOptions {\n  client: SanityClient\n  applicationId: string\n}\n\nexport async function deleteUserApplication({\n  applicationId,\n  client,\n}: DeleteUserApplicationOptions): Promise<void> {\n  await client.request({uri: `/user-applications/${applicationId}`, method: 'DELETE'})\n}\n\nexport async function getInstalledSanityVersion(): Promise<string> {\n  const sanityPkgPath = (await readPkgUp({cwd: __dirname}))?.path\n  if (!sanityPkgPath) {\n    throw new Error('Unable to resolve `sanity` module root')\n  }\n\n  const pkg = JSON.parse(await fs.readFile(sanityPkgPath, 'utf-8'))\n  if (typeof pkg?.version !== 'string') {\n    throw new Error('Unable to find version of `sanity` module')\n  }\n  return pkg.version\n}\n\nexport async function dirIsEmptyOrNonExistent(sourceDir: string): Promise<boolean> {\n  try {\n    const stats = await fs.stat(sourceDir)\n    if (!stats.isDirectory()) {\n      throw new Error(`Directory ${sourceDir} is not a directory`)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return true\n    }\n\n    throw err\n  }\n\n  const content = await fs.readdir(sourceDir)\n  return content.length === 0\n}\n\nexport async function checkDir(sourceDir: string): Promise<void> {\n  try {\n    const stats = await fs.stat(sourceDir)\n    if (!stats.isDirectory()) {\n      throw new Error(`Directory ${sourceDir} is not a directory`)\n    }\n  } catch (err) {\n    const error = err.code === 'ENOENT' ? new Error(`Directory \"${sourceDir}\" does not exist`) : err\n\n    throw error\n  }\n\n  try {\n    await fs.stat(path.join(sourceDir, 'index.html'))\n  } catch (err) {\n    const error =\n      err.code === 'ENOENT'\n        ? new Error(\n            [\n              `\"${sourceDir}/index.html\" does not exist -`,\n              '[SOURCE_DIR] must be a directory containing',\n              'a Sanity studio built using \"sanity build\"',\n            ].join(' '),\n          )\n        : err\n\n    throw error\n  }\n}\n"],"names":["debug","debugIt","extend","promiseWithResolvers","resolve","reject","promise","Promise","res","rej","getUserApplication","client","appHost","appId","query","uri","appType","default","request","e","statusCode","getUserApplications","organizationId","createUserApplication","body","method","selectExistingApplication","prompt","message","createNewLabel","userApplications","length","choices","map","app","value","name","title","selected","single","type","Separator","find","getOrCreateStudio","spinner","context","output","existingUserApplication","succeed","selectedApp","print","filter","inp","replace","validate","response","urlType","includes","getOrCreateCoreApplication","cliConfig","__experimental_coreAppConfiguration","undefined","input","tryCreateApp","generateId","firstChar","customAlphabet","rest","start","getOrCreateStudioFromConfig","fail","Error","getOrCreateCoreAppFromConfig","getOrCreateUserApplicationFromConfig","options","createDeployment","tarball","applicationId","isAutoUpdating","version","isCoreApp","formData","FormData","append","toString","contentType","filename","headers","getHeaders","pipe","PassThrough","deleteUserApplication","getInstalledSanityVersion","sanityPkgPath","readPkgUp","cwd","__dirname","path","pkg","JSON","parse","fs","readFile","dirIsEmptyOrNonExistent","sourceDir","stat","isDirectory","err","code","readdir","checkDir","join"],"mappings":"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"}