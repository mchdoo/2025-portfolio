{"version":3,"file":"index.cjs","sources":["../../src/selectors/selector.get-active-annotations.ts","../../src/selectors/selector.get-anchor-block.ts","../../src/selectors/selector.get-anchor-text-block.ts","../../src/selectors/selector.get-anchor-child.ts","../../src/selectors/selector.get-anchor-span.ts","../../src/selectors/selector.get-block-offsets.ts","../../src/selectors/selector.get-selection.ts","../../src/selectors/selector.get-value.ts","../../src/selectors/selector.is-point-after-selection.ts","../../src/selectors/selector.is-point-before-selection.ts","../../src/selectors/selector.is-overlapping-selection.ts"],"sourcesContent":["import {isPortableTextTextBlock, type PortableTextObject} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport const getActiveAnnotations: EditorSelector<Array<PortableTextObject>> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot)\n  const selectedSpans = getSelectedSpans(snapshot)\n\n  if (selectedSpans.length === 0) {\n    return []\n  }\n\n  const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n    isPortableTextTextBlock(block.node) ? (block.node.markDefs ?? []) : [],\n  )\n\n  return selectionMarkDefs.filter((markDef) =>\n    selectedSpans.some((span) => span.node.marks?.includes(markDef._key)),\n  )\n}\n","import type {KeyedSegment, PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isKeyedSegment} from '../utils'\n\n/**\n * @public\n */\nexport const getAnchorBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const key = snapshot.context.selection\n    ? isKeyedSegment(snapshot.context.selection.anchor.path[0])\n      ? snapshot.context.selection.anchor.path[0]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? snapshot.context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n","import {\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getAnchorBlock} from './selector.get-anchor-block'\n\n/**\n * @public\n */\nexport const getAnchorTextBlock: EditorSelector<\n  {node: PortableTextTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const anchorBlock = getAnchorBlock(snapshot)\n\n  return anchorBlock && isPortableTextTextBlock(anchorBlock.node)\n    ? {node: anchorBlock.node, path: anchorBlock.path}\n    : undefined\n}\n","import type {KeyedSegment} from '@portabletext/patches'\nimport type {PortableTextObject, PortableTextSpan} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isKeyedSegment} from '../utils'\nimport {getAnchorTextBlock} from './selector.get-anchor-text-block'\n\n/**\n * @public\n */\nexport const getAnchorChild: EditorSelector<\n  | {\n      node: PortableTextObject | PortableTextSpan\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  const anchorBlock = getAnchorTextBlock(snapshot)\n\n  if (!anchorBlock) {\n    return undefined\n  }\n\n  const key = snapshot.context.selection\n    ? isKeyedSegment(snapshot.context.selection.anchor.path[2])\n      ? snapshot.context.selection.anchor.path[2]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? anchorBlock.node.children.find((span) => span._key === key)\n    : undefined\n\n  return node && key\n    ? {node, path: [...anchorBlock.path, 'children', {_key: key}]}\n    : undefined\n}\n","import type {KeyedSegment} from '@portabletext/patches'\nimport {isPortableTextSpan, type PortableTextSpan} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getAnchorChild} from './selector.get-anchor-child'\n\n/**\n * @public\n */\nexport const getAnchorSpan: EditorSelector<\n  | {node: PortableTextSpan; path: [KeyedSegment, 'children', KeyedSegment]}\n  | undefined\n> = (snapshot) => {\n  const anchorChild = getAnchorChild(snapshot)\n\n  return anchorChild && isPortableTextSpan(anchorChild.node)\n    ? {node: anchorChild.node, path: anchorChild.path}\n    : undefined\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockOffset} from '../types/block-offset'\nimport * as utils from '../utils'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getBlockOffsets: EditorSelector<\n  {start: BlockOffset; end: BlockOffset} | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n\n  if (!selectionStartPoint || !selectionEndPoint) {\n    return undefined\n  }\n\n  const start = utils.spanSelectionPointToBlockOffset({\n    value: snapshot.context.value,\n    selectionPoint: selectionStartPoint,\n  })\n  const end = utils.spanSelectionPointToBlockOffset({\n    value: snapshot.context.value,\n    selectionPoint: selectionEndPoint,\n  })\n\n  return start && end ? {start, end} : undefined\n}\n","import type {EditorSelection} from '..'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getSelection: EditorSelector<EditorSelection> = (snapshot) => {\n  return snapshot.context.selection\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getValue: EditorSelector<Array<PortableTextBlock>> = (\n  snapshot,\n) => {\n  return snapshot.context.value\n}\n","import {isKeySegment, isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {reverseSelection} from '../utils/util.reverse-selection'\n\n/**\n * @public\n */\nexport function isPointAfterSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const selection = reverseSelection(snapshot.context.selection)\n\n    const pointBlockKey = isKeySegment(point.path[0])\n      ? point.path[0]._key\n      : undefined\n    const pointChildKey = isKeySegment(point.path[2])\n      ? point.path[2]._key\n      : undefined\n\n    const endBlockKey = isKeySegment(selection.focus.path[0])\n      ? selection.focus.path[0]._key\n      : undefined\n    const endChildKey = isKeySegment(selection.focus.path[2])\n      ? selection.focus.path[2]._key\n      : undefined\n\n    if (!pointBlockKey || !endBlockKey) {\n      return false\n    }\n\n    let after = false\n\n    for (const block of snapshot.context.value) {\n      if (block._key === endBlockKey) {\n        if (block._key !== pointBlockKey) {\n          after = true\n          break\n        }\n\n        // Both the point and the selection end in this block\n\n        if (!isPortableTextTextBlock(block)) {\n          break\n        }\n\n        if (!pointChildKey || !endChildKey) {\n          break\n        }\n\n        for (const child of block.children) {\n          if (child._key === endChildKey) {\n            if (child._key !== pointChildKey) {\n              after = true\n              break\n            }\n\n            // Both the point and the selection end in this child\n\n            after = point.offset > selection.focus.offset\n            break\n          }\n\n          if (child._key === pointChildKey) {\n            break\n          }\n        }\n      }\n\n      if (block._key === pointBlockKey) {\n        break\n      }\n    }\n\n    return after\n  }\n}\n","import {isKeySegment, isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {reverseSelection} from '../utils/util.reverse-selection'\n\n/**\n * @public\n */\nexport function isPointBeforeSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const selection = reverseSelection(snapshot.context.selection)\n\n    const pointBlockKey = isKeySegment(point.path[0])\n      ? point.path[0]._key\n      : undefined\n    const pointChildKey = isKeySegment(point.path[2])\n      ? point.path[2]._key\n      : undefined\n\n    const startBlockKey = isKeySegment(selection.anchor.path[0])\n      ? selection.anchor.path[0]._key\n      : undefined\n    const startChildKey = isKeySegment(selection.anchor.path[2])\n      ? selection.anchor.path[2]._key\n      : undefined\n\n    if (!pointBlockKey || !startBlockKey) {\n      return false\n    }\n\n    let before = false\n\n    for (const block of snapshot.context.value) {\n      if (block._key === pointBlockKey) {\n        if (block._key !== startBlockKey) {\n          before = true\n          break\n        }\n\n        // Both the point and the selection start in this block\n\n        if (!isPortableTextTextBlock(block)) {\n          break\n        }\n\n        if (!pointChildKey || !startChildKey) {\n          break\n        }\n\n        for (const child of block.children) {\n          if (child._key === pointChildKey) {\n            if (child._key !== startChildKey) {\n              before = true\n              break\n            }\n\n            // Both the point and the selection start in this child\n\n            before = point.offset < selection.anchor.offset\n            break\n          }\n\n          if (child._key === startChildKey) {\n            break\n          }\n        }\n      }\n\n      if (block._key === startBlockKey) {\n        break\n      }\n    }\n\n    return before\n  }\n}\n","import type {EditorSelection} from '../types/editor'\nimport type {EditorSelector} from './../editor/editor-selector'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {isPointAfterSelection} from './selector.is-point-after-selection'\nimport {isPointBeforeSelection} from './selector.is-point-before-selection'\n\n/**\n * @public\n */\nexport function isOverlappingSelection(\n  selection: EditorSelection,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!selection || !snapshot.context.selection) {\n      return false\n    }\n\n    const selectionStartPoint = getSelectionStartPoint({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n    const selectionEndPoint = getSelectionEndPoint({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n\n    if (!selectionStartPoint || !selectionEndPoint) {\n      return false\n    }\n\n    if (!isPointAfterSelection(selectionStartPoint)(snapshot)) {\n      return false\n    }\n\n    if (!isPointBeforeSelection(selectionEndPoint)(snapshot)) {\n      return false\n    }\n\n    return true\n  }\n}\n"],"names":["getActiveAnnotations","snapshot","context","selection","selectedBlocks","getSelectedBlocks","selectedSpans","getSelectedSpans","length","flatMap","block","isPortableTextTextBlock","node","markDefs","filter","markDef","some","span","marks","includes","_key","getAnchorBlock","key","isKeyedSegment","anchor","path","undefined","value","find","getAnchorTextBlock","anchorBlock","getAnchorChild","children","getAnchorSpan","anchorChild","isPortableTextSpan","getBlockOffsets","selectionStartPoint","getSelectionStartPoint","selectionEndPoint","getSelectionEndPoint","start","utils","selectionPoint","end","getSelection","getValue","isPointAfterSelection","point","reverseSelection","pointBlockKey","isKeySegment","pointChildKey","endBlockKey","focus","endChildKey","after","child","offset","isPointBeforeSelection","startBlockKey","startChildKey","before","isOverlappingSelection"],"mappings":";;;AAQO,MAAMA,uBACXC,CACG,aAAA;AACC,MAAA,CAACA,SAASC,QAAQC;AACpB,WAAO,CAAE;AAGX,QAAMC,iBAAiBC,6BAAAA,kBAAkBJ,QAAQ,GAC3CK,gBAAgBC,wCAAiBN,QAAQ;AAE/C,SAAIK,cAAcE,WAAW,IACpB,KAGiBJ,eAAeK,QAASC,CAChDC,UAAAA,MAAAA,wBAAwBD,MAAME,IAAI,IAAKF,MAAME,KAAKC,YAAY,CAAM,IAAA,CACtE,CAAA,EAEyBC,OAAQC,CAAAA,YAC/BT,cAAcU,KAAMC,CAAAA,SAASA,KAAKL,KAAKM,OAAOC,SAASJ,QAAQK,IAAI,CAAC,CACtE;AACF,GCtBaC,iBAERpB,CAAa,aAAA;AAChB,QAAMqB,MAAMrB,SAASC,QAAQC,aACzBoB,iBAAAA,eAAetB,SAASC,QAAQC,UAAUqB,OAAOC,KAAK,CAAC,CAAC,IACtDxB,SAASC,QAAQC,UAAUqB,OAAOC,KAAK,CAAC,EAAEL,OAE5CM,QAEEd,OAAOU,MACTrB,SAASC,QAAQyB,MAAMC,KAAMlB,CAAAA,UAAUA,MAAMU,SAASE,GAAG,IACzDI;AAEJ,SAAOd,QAAQU,MAAM;AAAA,IAACV;AAAAA,IAAMa,MAAM,CAAC;AAAA,MAACL,MAAME;AAAAA,IAAI,CAAA;AAAA,EAAA,IAAKI;AACrD,GCVaG,qBAER5B,CAAa,aAAA;AACV6B,QAAAA,cAAcT,eAAepB,QAAQ;AAE3C,SAAO6B,eAAenB,MAAAA,wBAAwBmB,YAAYlB,IAAI,IAC1D;AAAA,IAACA,MAAMkB,YAAYlB;AAAAA,IAAMa,MAAMK,YAAYL;AAAAA,EAAAA,IAC3CC;AACN,GCVaK,iBAMR9B,CAAa,aAAA;AACV6B,QAAAA,cAAcD,mBAAmB5B,QAAQ;AAE/C,MAAI,CAAC6B;AACH;AAGF,QAAMR,MAAMrB,SAASC,QAAQC,aACzBoB,iBAAAA,eAAetB,SAASC,QAAQC,UAAUqB,OAAOC,KAAK,CAAC,CAAC,IACtDxB,SAASC,QAAQC,UAAUqB,OAAOC,KAAK,CAAC,EAAEL,OAE5CM,QAEEd,OAAOU,MACTQ,YAAYlB,KAAKoB,SAASJ,KAAMX,CAAAA,SAASA,KAAKG,SAASE,GAAG,IAC1DI;AAEJ,SAAOd,QAAQU,MACX;AAAA,IAACV;AAAAA,IAAMa,MAAM,CAAC,GAAGK,YAAYL,MAAM,YAAY;AAAA,MAACL,MAAME;AAAAA,IAAI,CAAA;AAAA,EAAA,IAC1DI;AACN,GC3BaO,gBAGRhC,CAAa,aAAA;AACViC,QAAAA,cAAcH,eAAe9B,QAAQ;AAE3C,SAAOiC,eAAeC,MAAAA,mBAAmBD,YAAYtB,IAAI,IACrD;AAAA,IAACA,MAAMsB,YAAYtB;AAAAA,IAAMa,MAAMS,YAAYT;AAAAA,EAAAA,IAC3CC;AACN,GCRaU,kBAERnC,CAAa,aAAA;AACZ,MAAA,CAACA,SAASC,QAAQC;AACpB;AAGF,QAAMkC,sBAAsBC,6BAAAA,uBAAuBrC,QAAQ,GACrDsC,oBAAoBC,kDAAqBvC,QAAQ;AAEnD,MAAA,CAACoC,uBAAuB,CAACE;AAC3B;AAGIE,QAAAA,QAAQC,iBAAAA,gCAAsC;AAAA,IAClDf,OAAO1B,SAASC,QAAQyB;AAAAA,IACxBgB,gBAAgBN;AAAAA,EAAAA,CACjB,GACKO,MAAMF,iDAAsC;AAAA,IAChDf,OAAO1B,SAASC,QAAQyB;AAAAA,IACxBgB,gBAAgBJ;AAAAA,EAAAA,CACjB;AAED,SAAOE,SAASG,MAAM;AAAA,IAACH;AAAAA,IAAOG;AAAAA,EAAAA,IAAOlB;AACvC,GC3BamB,eAAiD5C,CACrDA,aAAAA,SAASC,QAAQC,WCDb2C,WACX7C,CAEOA,aAAAA,SAASC,QAAQyB;ACDnB,SAASoB,sBACdC,OACyB;AACzB,SAAQ/C,CAAa,aAAA;AACf,QAAA,CAACA,SAASC,QAAQC;AACb,aAAA;AAGT,UAAMA,YAAY8C,sBAAAA,iBAAiBhD,SAASC,QAAQC,SAAS,GAEvD+C,gBAAgBC,MAAAA,aAAaH,MAAMvB,KAAK,CAAC,CAAC,IAC5CuB,MAAMvB,KAAK,CAAC,EAAEL,OACdM,QACE0B,gBAAgBD,MAAAA,aAAaH,MAAMvB,KAAK,CAAC,CAAC,IAC5CuB,MAAMvB,KAAK,CAAC,EAAEL,OACdM,QAEE2B,cAAcF,MAAAA,aAAahD,UAAUmD,MAAM7B,KAAK,CAAC,CAAC,IACpDtB,UAAUmD,MAAM7B,KAAK,CAAC,EAAEL,OACxBM,QACE6B,cAAcJ,MAAAA,aAAahD,UAAUmD,MAAM7B,KAAK,CAAC,CAAC,IACpDtB,UAAUmD,MAAM7B,KAAK,CAAC,EAAEL,OACxBM;AAEA,QAAA,CAACwB,iBAAiB,CAACG;AACd,aAAA;AAGT,QAAIG,QAAQ;AAED9C,eAAAA,SAAST,SAASC,QAAQyB,OAAO;AACtCjB,UAAAA,MAAMU,SAASiC,aAAa;AAC1B3C,YAAAA,MAAMU,SAAS8B,eAAe;AACxB,kBAAA;AACR;AAAA,QAAA;AASF,YAJI,CAACvC,MAAAA,wBAAwBD,KAAK,KAI9B,CAAC0C,iBAAiB,CAACG;AACrB;AAGSE,mBAAAA,SAAS/C,MAAMsB,UAAU;AAC9ByB,cAAAA,MAAMrC,SAASmC,aAAa;AAC1BE,gBAAAA,MAAMrC,SAASgC,eAAe;AACxB,sBAAA;AACR;AAAA,YAAA;AAKMJ,oBAAAA,MAAMU,SAASvD,UAAUmD,MAAMI;AACvC;AAAA,UAAA;AAGF,cAAID,MAAMrC,SAASgC;AACjB;AAAA,QAAA;AAAA,MAEJ;AAGF,UAAI1C,MAAMU,SAAS8B;AACjB;AAAA,IAAA;AAIGM,WAAAA;AAAAA,EACT;AACF;ACzEO,SAASG,uBACdX,OACyB;AACzB,SAAQ/C,CAAa,aAAA;AACf,QAAA,CAACA,SAASC,QAAQC;AACb,aAAA;AAGT,UAAMA,YAAY8C,sBAAAA,iBAAiBhD,SAASC,QAAQC,SAAS,GAEvD+C,gBAAgBC,MAAAA,aAAaH,MAAMvB,KAAK,CAAC,CAAC,IAC5CuB,MAAMvB,KAAK,CAAC,EAAEL,OACdM,QACE0B,gBAAgBD,MAAAA,aAAaH,MAAMvB,KAAK,CAAC,CAAC,IAC5CuB,MAAMvB,KAAK,CAAC,EAAEL,OACdM,QAEEkC,gBAAgBT,MAAAA,aAAahD,UAAUqB,OAAOC,KAAK,CAAC,CAAC,IACvDtB,UAAUqB,OAAOC,KAAK,CAAC,EAAEL,OACzBM,QACEmC,gBAAgBV,MAAAA,aAAahD,UAAUqB,OAAOC,KAAK,CAAC,CAAC,IACvDtB,UAAUqB,OAAOC,KAAK,CAAC,EAAEL,OACzBM;AAEA,QAAA,CAACwB,iBAAiB,CAACU;AACd,aAAA;AAGT,QAAIE,SAAS;AAEFpD,eAAAA,SAAST,SAASC,QAAQyB,OAAO;AACtCjB,UAAAA,MAAMU,SAAS8B,eAAe;AAC5BxC,YAAAA,MAAMU,SAASwC,eAAe;AACvB,mBAAA;AACT;AAAA,QAAA;AASF,YAJI,CAACjD,MAAAA,wBAAwBD,KAAK,KAI9B,CAAC0C,iBAAiB,CAACS;AACrB;AAGSJ,mBAAAA,SAAS/C,MAAMsB,UAAU;AAC9ByB,cAAAA,MAAMrC,SAASgC,eAAe;AAC5BK,gBAAAA,MAAMrC,SAASyC,eAAe;AACvB,uBAAA;AACT;AAAA,YAAA;AAKOb,qBAAAA,MAAMU,SAASvD,UAAUqB,OAAOkC;AACzC;AAAA,UAAA;AAGF,cAAID,MAAMrC,SAASyC;AACjB;AAAA,QAAA;AAAA,MAEJ;AAGF,UAAInD,MAAMU,SAASwC;AACjB;AAAA,IAAA;AAIGE,WAAAA;AAAAA,EACT;AACF;ACvEO,SAASC,uBACd5D,WACyB;AACzB,SAAQF,CAAa,aAAA;AACnB,QAAI,CAACE,aAAa,CAACF,SAASC,QAAQC;AAC3B,aAAA;AAGT,UAAMkC,sBAAsBC,6BAAAA,uBAAuB;AAAA,MACjD,GAAGrC;AAAAA,MACHC,SAAS;AAAA,QACP,GAAGD,SAASC;AAAAA,QACZC;AAAAA,MAAAA;AAAAA,IACF,CACD,GACKoC,oBAAoBC,kDAAqB;AAAA,MAC7C,GAAGvC;AAAAA,MACHC,SAAS;AAAA,QACP,GAAGD,SAASC;AAAAA,QACZC;AAAAA,MAAAA;AAAAA,IACF,CACD;AAUD,WARI,EAACkC,CAAAA,uBAAuB,CAACE,qBAIzB,CAACQ,sBAAsBV,mBAAmB,EAAEpC,QAAQ,KAIpD,CAAC0D,uBAAuBpB,iBAAiB,EAAEtC,QAAQ;AAAA,EAKzD;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}